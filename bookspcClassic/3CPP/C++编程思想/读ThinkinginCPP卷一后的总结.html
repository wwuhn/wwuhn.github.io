<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:65.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h3{
	font-size:1.1em;
	font-weight:bold;
	text-indent:0em;
	color:#990000;
}
h4{
	font-size:1.0em;
	font-weight:bold;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	margin-left:2em;
	color:blue;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style>
</head>

<body>

<div id="container">





<h4>读ThinkinginCPP卷一后的总结</h4>

<p><a href="https://blog.51cto.com/remyspot/1555464" title="">Remyspot</a></p>
<p>断断续续的学习C++编程已经有一年多的历史了，在学习了一些基本的语法后，基本可以使用C++语言编程，也拿这个语言参加比赛实现了比较复杂的算法。当时很得意，觉得C++语言也就那么回事，殊不知在大三实习面试的过程中，大部分面试在考察对C++的理解和编程实践方面都会问看了C++方面的哪些书籍，很多都会问有没有看过Thinking in C++，还会考察对STL的理解，如容器，迭代器，算法等。而这些都是我没注意过的，备受打击的我决定要仔细研读Thinking in C++。当我在Internet上搜索Thinking in C++时，我才发现大家这本书的评价非常高，这更坚定了我读这本书的决心。随着对这本书的深入，我才发现作为一个计算机专业的学生，我以前对编程语言的理解是多么的肤浅。这本书让我明白对编程语言的理解最起码要从编译器的角度来思考，只有从编译器的角度来思考自己编写的程序了，自己的编程技艺才算真正的入了门。但是要记住对编程语言的熟练掌握也仅仅是掌握了一种使用工具的技能，而算法才是一切的灵魂。</p>
<p>Thinking in C++共有两卷，第一卷主要讲解了C++的一些基本特性（可概括为面向对象的三大特性和模板机制），作者对这些特性剖析的非常深入，不仅告诉你这些特性是这样的，还告诉你这些特性为什么会被设计成这样，了解了第一卷的内容，使用C++语言编程时你将拥有更多的自信，敲代码时会觉得非常有力，而且时刻会考虑和审视自己的代码，会思考为什么要这样实现设计；第二卷主要讲解了C++的一些高级特性，如如何构建稳定的系统，STL，以及一些专题部分，本人还未完成该卷的研读，现仅完成了5章的内容，所以不做过多的陈述。这里主要对第一卷的内容做做总结，总结C++的基本特性的重要内容以及自己的一些体会，以后也会对第二卷做一个总结。</p>
<p>Thinking in C++第一卷中共有16章内容，前3章内容是对象导言，对象的创建与使用以及C++中的C，对于这3章内容这里不做总结，因为第2章和第3章的内容都是一些基本的内容，很容易掌握，而对于第1章的内容，我的建议是读完整本书后对什么是面向对象编程有深刻理解后再看也不迟。我还建议，研读Thinking in C++最好看英文版的，因为中文版的翻译很多地方有错误，如果英文不太好，可以中文英文对比着看。</p>
<p>下面开始进入主题吧，对于第一卷的4到16章的内容，我分为四个部分来做出总结，具体如下：</p>
<p>一、面向对象特性之一封装，包括下列章节内容：</p>
<p>第4章：数据抽象、第5章：隐藏实现、第6章：初始化和清除、第7章：函数重载和默认参数、第8章：常量、第9章：内联函数、第10章：名字控制、第11章：引用和复制构造函数、第12章：运算符重载、第13章：动态对象创建。</p>
<p>这个部分的内容多而且杂，但整体上来看都是为封装服务的，于是将它们归于一类，后面会对每一章节做出总结。</p>
<p>二、面向对象特性之二继承，包括一章的内容：</p>
<p>第14章：继承和组合。</p>
<p>   这章的内容会讨论如何选择继承和组合的问题。</p>
<p>三、面向对象特性之三多态，包括一章的内容：</p>
<p>第15章：多态性和函数。</p>
<p>实际上前面封装和继承两部分的内容都是为多态服务的，它们是多态机制实现的基础。这章的内容将会讨论多态的很多特性。</p>
<p>四、面向对象编程很重要的一个内容，模板机制，包括一章的内容：</p>
<p>第16章：模板介绍。</p>
<p>模板是面向对象编程不可或缺的一个特性，它提供了重用源代码的方法，有了模板机制才有了像STL这样优秀的库，极大的提高了编程效率。</p>
<p> </p>
<h3>一、封装</h3>
<p><h4>1.数据抽象</h4></p>
<p>数据抽象，简单一点来讲就ADT，就是将作用在一个数据集合上的一些操作函数和该数据集合放在一起，这个"放在一起"指的是逻辑代码上的，而非物理内存上的。如将作用在结构体数据上的操作函数，放到结构体内部，这就形成了一个ADT。使用这个结构创建的变量就叫做这个结构类型的对象，调用该对象的成员函数就是向该对象发送消息。将数据和函数捆绑在一起的好处是可以防止名字冲突。</p>
<p>该章内容除了数据抽象外，还应该注意的内容包括：C++中的无数据结构应当拥有最小的非零长度（C中是不合法的）；C++中有严格的类型检查（解决这个问题可以使用C++的显示转换）；头文件和实现文件分离，头文件是放置接口规范的地方（声明），而实现文件对声明定义，且只能定义一次，头文件中不应当使用using指令，这将破坏名字空间保护。</p>
<p> </p>
<p><h4>2.隐藏实现</h4></p>
<p>该章重点讨论了结构中的边界问题。这让我想起了搞研究，对于研究对象，我们首先应思考的是该对象的外延，而后内涵。外延实际上就是研究对象的范围内的元素组成的集合，在这个集合外的东西是跟对该对象的研究无关的，也就是确定我们研究的重点范围是什么。这里的边界问题和这个类似，不同的人对一个结构的关注重点是不一样的，如开发该结构的人重点关注该结构的实现，如public、protected、private成员和函数的确定或实现，他们研究对象的外延就是整个结构中的元素（成员和函数）；而对于使用该结构的人来说，这个结构是怎么实现的并不关注，他们关注的是这个结构提供给我哪些功能，他们研究对象的外延就是该结构中的public元素。C++就是通过public、protected、private访问控制确定了结构中的边界问题（当然也是逻辑代码上的，而不是物理内存上的，访问控制只在编译期间有效，而运行期间不再检查）。</p>
<p>C++中还有友元的概念，当在一个结构中声明了友元（全局函数或结构中的函数或整个结构）时，那么该友元就可以访问该结构中的成员或函数，从friend的角度来看，C++不是一个纯面向对象的语言。</p>
<p>如果将一个结构的struct关键字换成class，那么这就是类了。结构和类的区别在于，结构默认访问控制是public，而类的默认访问控制是private。</p>
<p>对于有些保密性比较强的项目，虽然客户不能够看到其实现部分，但可能在头文件中看到一些策略信息。如头文件中可以看到的一些private函数的声明，客户虽然不能直接调用它们，但仍然看得见其声明。如何将这些private可见的函数或成员声明也隐藏起来呢？可以使用句柄类技术，其简单的一个例子描述如下：</p>
<p>头文件：</p>
<pre>
#ifndef HANDLE_H
#define HANDLE_H
class Handle {
    struct Cheshire; // Class declaration only
    Cheshire* smile;
public:
    void initialize();
    void cleanup();
    int read();
    void change(int);
};
#endif //HANDLE_H
</pre>
<p>实现文件：</p>
<pre>
#include "Handle.h"
#include "../require.h"
// Define Handle's implementation:
struct Handle::Cheshire {
    int i;
};
void Handle::initialize() {
    smile = new Cheshire;
    smile->i = 0;
}
void Handle::cleanup() {
    delete smile;
}
int Handle::read(){
    return smile->i;
}
void Handle::change(int x) {
    smile->i = x;
}
</pre>
<p>可以看到，在实现文件中定义Cheshire结构，然后在类的构造函数中初始化Cheshire结构类型的smile指针，这样在public的成员函数中通过smile指针来调用Cheshire结构中的数据或函数。这样客户在头文件中只能看见public数据和函数，而不见private的数据或函数，因此也看不见可能会泄露的策略信息。</p>
<p>句柄类技术还解决了重复编译的问题。当一个文件被修改或其包含的头文件（共有或私有成员的声明部分）被修改，那么该文件都要重新编译。而句柄类技术将更多的声明部分放到了实现文件中，这样只要头文件不变，那么包含该头文件的文件就需要变动，而实现文件可以任意的改动，完成后只需要对实现文件进行重编译。</p>
<p> </p>
<p><h4>3.初始与清除</h4></p>
<p>编程中很多错误的发生都是错误的初始化或清除引起的，因此C++在初始和清除做了很多工作。C++对象的初始化是构造函数完成的，清除对象是析构函数完成的。当一个对象被声明后C++总是试图调用构造函数对它进行初始，当该对象超出作用域后总会调用析构函数。构造函数调用时，编译器会传递一个this指针到构造函数，这个this指针指向的是对象数据成员的内存地址，也就是对象的地址。</p>
<p>当一个结构中没有构造函数，编译器会自动为它创建一个默认构造函数，但这个编译器合成的默认构造函数很多时候完成的工作并不是我们期待的。编译器合成的默认构造函数只会对全局变量（未初始化或对象默认初始）进行初始，如果全局变量是对象并默认初始，则该对象须有默认构造函数；而对于结构中的成员数据，如果成员数据是内置类型（int,float,char,*等）是不会对它们进行初始的，如果成员数据是对象则该对象必须有默认构造函数。因此我们应该明确自己的构造函数，而不让编译器来完成。对于结构中的成员数据，它们的初始都应该在构造函数参数列表中完成，有的情况下应该在函数体中完成。如数据成员为内部类型的数组时，因为其没有默认构造函数，因此放到函数体中是合理的，当然一个更好的方法是将内置类型封装成类，再添加一个默认构造函数，这样不需要在参数列表中或函数体中显示初始化，编译器就能够帮助完成默认的初始化。</p>
<p> </p>
<p><h4>4.函数重载与默认参数</h4></p>
<p>函数重载的主要目的是方便的使用函数名，根据函数参数列表的不同来选择调用函数，也就是同一个函数名的函数实现有区别的功能，但它们的功能又有共性，如构造函数，它们都是完成初始化工作的。默认参数的作用则是减少了函数重载的数量。如：stash(int size); stash(int size, int initQuantity);可以用一个函数来代替stash(intsize, int initQuantity=0);。默认参数只能放在函数声明中，编译器必须在使用函数前知道默认值，有时为了阅读方便在函数定义处放一些默认值的注释。</p>
<p>函数重载和默认参数选择的问题：1）如果一个默认值成了一个标识，就意味着函数体中使用了两个不同的有效版本，一个用于正常情况，一个用于错误情况。这种情况还不如使用两个不相干的函数来维护两段代码，这样维护更方便一些，尤其函数比较大时。2）当发现两个函数在使用默认参数后根本不会导致函数的定义改变时，可以使用默认参数将两个函数合并。</p>
<p> </p>
<p><h4>5.常量</h4></p>
<p>const最初的动机是代替预处理来进行值代替。从这以后它被用到指针、函数参数传递和返回、类对象及类成员数据和函数。</p>
<p>1）C++中的const与C中的const的区别</p>
<p>当在C++中定义一个constint a = 5;时，编译器不仅会为a分配空间而且会将a的定义保存到符号表里，这就是常量折叠，编译期间是可以确定a的值的，因此再用a来定义数组长度时不会有什么错误，如int b[a];。而在C中这样是不可以的，因为C编译器会分配空间但不会进行常量折叠。C++中的const用于集合时，如数组，C++编译器不会复杂到将整个集合保存到符号表中，因此编译期间是不知道集合中的元素值的，即使以对该集合初始化了。</p>
<p>C++中的const与C中的const的另一个区别是它们的链接方式，C++中默认内部链接，而C中默认外部链接。要使C++中的const具有外部链接，那么在定义该const变量的文件中要类似这样定义:extern const int a = 5;，该文件中编译器仍然常量折叠。在其它文件中要使用该const变量时，需先声明如下：extern const int a;，但在该文件中编译器就不能常量折叠了。</p>
<p>2）const和指针</p>
<p>const和指针一起可以构成指向const的指针和cosnt指针。指向const的指针声明可以如下：cosntint* u;或int cons* u;，其意义是不能通过u指针修改u指向的空间的内容，因为该内容是cosnt的。Const指针声明如下：int* const w;，其意义是不能修改w的指向，因为该指针变量是const的。</p>
<p>C++对类型检查是非常精细的，这也扩展到指针赋值，如不可以把一个const对象的地址赋给一个非const指针。当然总能用强制类型转换实现这样的赋值。</p>
<p>一个没有强调const的地方是字符串常量，如char*p = "howdy";，这不会报错，但当通过p指针对"howdy"进行修改是往往会导致运行时错误，当然不是所有的编译器都可以做到这一点的。</p>
<p>3）const和函数的参数和返回值</p>
<p>当按值传递或返回一个内部类型时，const是没有用的。值传递很明显，const没有意义，当按值返回一个内部类型时，const没有意义的原因是，它是一个值而不是一个变量。</p>
<p>如果按值传递对象，用const限制没有意义； 如果按值返回一个用户自定义的const对象，这意味着返回值不会被修改，不能为左值。</p>
<p>如果传递并返回地址，则const将保证该地址的内容不会被改变。当const限定传递的指针或引用时，则表明在该函数中不能对指针指向的空间或与引用相关联的空间进行修改。而返回一个const指针或引用则取决于设计该函数的程序员想干什么。</p>
<p>从上面的内容可以看出：当按值返回内部类型或任何类型的指针时，均不能为左值；而返回自定义对象或引用则可以为左值，除非使用const进行限定。</p>
<p>标准参数传递：参数传递时，如果想在函数体中对该传递参数的值进行改变最好用指针的方式传递，如果不想改变则使用const引用的方式传递。</p>
<p>4）const和类</p>
<p>在类里创建一个非static的const变量时，不能给它初值，这个初值必须在构造函数参数列表中进行，这里是初始所有类里的const的地方。而当在类里创建一个static const时，如果是一个内部类型，可以直接初始化，则该常量可以被看作一个编译期间的常量，如可以使用该常量去定义数组的长度。个人觉得在类里的const成员都应该同时为static，能在声明时初始化的可以直接初始化，不能够在声明时直接初始化的（见7中的3）部分）可以使用标准的static数据成员的初始化方法，因为当类数据成员为一个const数组时，产生多个对象时不仅浪费空间（每个对象都要为const数组成员分配空间，却又不对其做任何改变），而且在构造函数中对其初始化也同样很麻烦（见3的第二段），若为static const则更为合理。</p>
<p>const也可用于对象或类中的成员函数。当const修饰类中的成员函数时，意义是该函数不会对对象的数据部分做任何的修改，当希望某个数据成员能够在const函数中被修改则可以将该数据成员声明为mutable；通过const对象只能调用公有的const成员函数或数据。</p>
<p>5）volatile</p>
<p>volatile和const类似，它可用于对象或类里的成员函数和数据。volatile的含义是，对于volatile修饰的变量，编译器将不对它做任何的优化，每一次对它的引用都会直接从内存中读取。通过volatile对象只能调用volatile成员函数。</p>
<p> </p>
<p><h4>6.内联函数</h4></p>
<p>内联函数的出现主要是为了消除预处理器的缺陷，预处理器不仅会引起一些side effect，而且也没有类作用域的概念。内联函数在具备宏高效的性质外，同时又有类作用域的概念和接受C++访问控制（private等）的保护。使用inline时，必须在函数定义是给出，声明时给出inline关键字是无效的。</p>
<p>1）内联函数与编译器</p>
<p>编译器遇到一个内联函数时，它会检查函数参数列表，编译器一定要能够进行参数类型转换，返回类型正确，然后让内联函数代码代替这个函数调用语句，而后把对象的this指针放到恰当的位置，而预处理器只会替换而不会做其它的工作。</p>
<p>使用inline关键字也有一些限制。假如函数太复杂编译器是不能执行内联的；假如要显式或隐式的取函数的地址，编译器也拒绝内联，因为取地址意味着要给函数代码分配空间，但当地址不需要时，编译器仍可能内联代码，这样就造成了取地址时分配空间的浪费；内联函数要是小的，简单的，才会具有宏效率的函数调用，这样的话鉴于构造函数和析构函数中会有隐藏的其它的初始化和清除操作，因此当对程序效率做出考虑时，那么构造函数和析构函数是否内联是一个值得注意的问题。</p>
<p>2）预处理器更多的特性</p>
<p>当然预处理器也有它自己的优点，了解预处理器更多的特性对于代码调试阶段是很有帮助的。如字符串组合：#define DEBUG(x) cout &lt;&lt;  #x"="  &lt;&lt; x  &lt;&lt; endl;，其中#表示字符串定义，输出x的字面值。</p>
<p>标识联贴使用##实现，它允许设两个标识符并把他们联贴在一起自动产生一个新的标识符。例如：</p>
<pre>
#define FIELD(a) char* a##_string; int a##_size;
 class Record {
     FIELD(one)
     FIELD(two)
     //…..
 };
</pre>
<p><h4>7.名字控制</h4></p>
<p>标识符命名冲突在早期的编程中是一个很大的问题，特别是项目比较大的时候。尽管类的出现减少了标识符命名冲突的可能性，但这还远远不够，为了更好的解决名字冲突带来的麻烦，C++在将来自C的static关键字扩展到对象和类中的成员外，也引入了命名空间。</p>
<p>本章内容主要包括：static如何控制存储和可见性；C++的命名空间控制访问；使用采用C语言编写和编译过的函数。</p>
<p>1）C++中的static关键字</p>
<p>C++中的static关键字和C中static关键字都有两个基本意思：在静态区分配存储；对于一个特定编译单元是局部可见的。对C++中的static关键字总结如下：</p>
<p>static修饰全局变量：静态区存储；未初始化会被初始化为0；仅本文件可见。</p>
<p>static修饰局部变量：静态区存储；第一次调用函数是初始化，未初始化会被初始化为0；作用域仅限于函数内部。</p>
<p>static修饰全局对象，局部对象：一一对应于全局变量和局部变量，只是若未给出初始化定义则需提供默认构造函数。</p>
<p>static修饰全局函数：静态区存储；无普通函数的进栈出栈，速度快；避免与其它文件函数的名字冲突；声明时需给出定义。</p>
<p>static修饰类中的成员：类的所有对象共享static成员（变量，对象，函数）；变量、对象成员的定义必须在类的外部；函数成员调用时不会传递this指针，因此它是不能访问类中的非静态成员的。</p>
<p>2）命名空间</p>
<p>一个命名空间可以在多个文件中使用；一个命名空间可以用另一个名字来作为它的别名，这样就不必敲那些开发商提供的冗长的命名空间名字，如namespace Bob = Bob-------library;，Bob-------library命名空间中是开发商提供的库文件；在一个命名空间中的类中使用友元，也就意味着该友元也就是该命名空间的一个成员了。</p>
<p>每个翻译单元都可以包含一个未命名的命名空间，可以不用标识符而只用"namespace"增加一个名字空间，每个翻译单元都只有一个未命名的命名空间。如果把一个局部名字放在一个未命名的命名空间中，不需要加static说明就可以让他们内部链接。</p>
<p>使用命名空间的三种方法：作用域运算符；用using指令将整个命名空间引入；使用using声明一次性引用。using声明是在当前范围之内进行的一个声明，这就意味着它可以不顾来自using指令的名字。</p>
<p>不要把一个全局的using指令放到头文件中，因为包含这个头文件的其它文件也会打开这个命名空间。因此在头文件中应当使用明确限定或在一定范围内的using指令和using声明。</p>
<p>3）C++类中的静态数据成员初始化</p>
<p>C++类中的静态数据成员的初始化必须在类的外部进行显式初始化。如果是内置类型的static const数据成员是可以在类中给出定义的，但是对于数组或其它类型的静态常量（static const）必须为他们提供专门的外部定义，它们的定义语法遵循典型的静态数据成员定义语法。</p>
<p>因为静态数据成员的初始化特点，使得一个类只能创建一个对象成为可能，这就是Singleton模式。一个简单的例子如下：</p>
<pre>
class Egg {
   static Egg e;
   int i;
   Egg(intii) : i(ii) {}
   Egg(constEgg&); //prevent copy constructor
public:
   static Egg* instance() {
       return&e;
   }
   int val() const{
       return i;
   }
};
Egg Egg::e(47);
</pre>
<p>这样Egg类只有一个对象存在，可以访问那个对象，但不能产生任何新的对象。必须使拷贝构造函数私有，不然就可以用如下方法创建新的Egg对象：Egg e= *Egg::instance();。</p>
<p>4）静态初始化的相依性</p>
<p>静态初始的相依性问题，可以用这样一个例子来说明，假设一个cpp文件中有如下两行代码：extern int y; int x = y + 1;，另一个cpp文件中有如下两行代码:extern int x; int y = x + 1;；如果第一个cpp文件先编译，第二个cpp文件后编译，那么在第一个文件中y先被初始为0，接着x初始化为1，然后在第二个文件中，y被初始为2；如果第二个cpp文件先编译，第一个cpp文件后编译，那么在第二个文件中x被初始为0，y被初始化为1，然后在第一个文件中x被初始化为2。这样编译的顺序不同会导致初始结果的不同，这是一个问题。</p>
<p>解决这个问题的方法有三种：不用；如果实在要用，把那些关键的静态变量的定义放到一个文件中（同一个翻译单元），这样只要他们在文件中的顺序正确就可以保证他们正确的初始化；如果有时必须把静态变量放在几个不同的翻译单元中（如写一个库的时候），可以通过两种程序设计技术解决。</p>
<p>技术一例子如下：</p>
<p></p>

<pre>
//Initializer.h
extern int x;
extern int y;
class Initializer {
    static int initCount;
public:
    Initializer() {
        if(initCount++==0) {
            x = 100;
            y = 200;
        }
    }
    ~Initializer(){
        if(--initCount) {
            //anynecessary clean up
        }
    }
};
staticInitializer init;
//Initializer.cpp   #include"Initializer.h"
int x; int y; int Initializer::initCount;
</pre>

<p> </p>
<p>现假设使用该库的程序员产生了两个其它文件：</p>
<pre>
//Initializer1.cpp
#include "Initializer.h"
 
//Initializer2.cpp
#include "Initializer.h"
    int main(void) {
}
</pre>
<p>现在哪个翻译单元先初始化staticInitializer init都没有关系。当第一次包含Initializer.h的翻译单元被初始化时，initCount为0，这时对x，y的初始化就已经完成了。解释这个问题，需要知道main函数执行之前发生了哪些事，在main函数执行之前编译器插入的start_函数会对应用程序运行时所需资源进行初始化，如对栈的分配，堆的分配，static变量有定义的放在data段，static变量无定义的置为0放bss段，运行全局构造函数，传递main函数参数，然后才开始运行mian函数。这里的initCount没有定义其初始值，那么它会被置0放到bss段，然后运行全局构造函数时才会对各个cpp文件中的static Initializerinit对象初始化，这样除第一次包含Initializer.h的翻译单元被初始化时initCount为0外，对于其余单元，initCount不会为0，忽略对x，y的初始化操作。清除时将按包含头文件的各个翻译单元中的static Initializer init的初始化顺序相反的顺序发生，且~Initializer()可确保清除只发生一次。</p>
<p>技术二例子如下：</p>
<pre>
//Dependency1.h
class Dependency1 {
    bool init;
public:
    Dependency1(): init(true) {}
};
 
//Dependency2.h
#include "Dependency1.h"
class Dependency2 {
    Dependency1 d1;
public:
    Dependency2(const Dependency1 dep1) : d1(dep1) {}
};
 
//Dependency1StatFun.h
#include "Dependency1.h"
extern Dependency1& d1();
 
//Dependency2StatFun.h
#include "Dependency2.h"
extern Dependency2& d2();
 
//Dependency1StatFun.cpp
#include "Dependency1StatFun.h"
Dependency1& d1() {
     static Dependency1 dep1;
     return dep1;
}
 
//Dependency2StatFun.cpp
#include "Dependency2StatFun.h"
Dependency2& d2() {
     stati cDependency2 dep2(d1());
     return dep2;
}
</pre>
<p>通过对各个静态变量进行封装成类，在构造函数中对各个静态变量进行正确顺序的初始化。然后为各个静态变量定义全局函数，在各自函数中有一个各静态变量被封装成的类的一个静态对象，通过全局函数返回其函数内部的静态对象的引用来达到对相关静态变量的访问。当第一次调用这些全局函数时，函数中的静态对象的构造函数总能够保证与其相关联的静态变量被正确的初始化。</p>
<p>5）代替连接说明</p>
<p>如果在C++中编写一个程序需要用到C库，那么该怎么办？如果声明这样一个C函数：float f(int a, char b);，C++的编译器就会将这个名字变成类似_f_int_char这样的名字，而C编译器一般不做这样的转换，所以它的库内部名字为_f。这样C++连接器将无法解释对C库中的f的调用。</p>
<p>C++提供了一个代替连接说明，它是通过重载extern关键字来实现的。extern后跟一个字符串，指定箱声明的函数的连接类型，后面是函数声明，如下：</p>
<p>extern "C" floatf(int a, char b);</p>
<p>这就告诉编译器f()是C连接，这样就不会转换函数名。标准的连接类型指定符有"C"和"C++"两种。</p>
<p>如果有一组替代连接的说明，可以把它们放在花括号内:</p>
<pre>
extern "C" {
    float f(int a, char b);
    double d(int a, char);
}
或在头文件中:
extern "C" {
    #include "header.h"
}
</pre>
<p> </p>
<p><h4>8.引用和拷贝构造函数</h4></p>
<p>C++中引用和指针的区别在于，指针强调的是指向，而引用强调的是关联。引用的引入丰富了函数参数传递和返回的方式，引用在复制构造函数和重载运算符函数的使用，大大的丰富了C++的特性，使得C++提供给了我们更多方便的程序设计方式。</p>
<p>1）C++中的引用</p>
<p>C++是一个类型严格检查的语言，如果要把某种类型当做别的类型处理，必须显式的转换。这阻止了在C中的void*指针使得任意类型的指针之间进行赋值的功能（如：bird* b; rock* r; void* v; v=r; b = v;）。</p>
<p>C++除了对指针的使用限制的更加严格外，还引入了引用。指针与引用最大的区别在于，指针强调指向，而引用强调关联，指针的指向可以改变，而引用的关联一旦建立就不会改变。因此一个引用创建时，必须为它初始化，而指针则可以在任何时候初始化；一旦一个引用被初始化关联到一个对象后，它就只能和该对象关联，而不能通过修改它而关联到其它的对象，相当于为其关联到的对象取了另外一个名字；引用不可能为null，必须保证引用和一块合法的存储单元相关联。</p>
<p>引用也常见于函数的参数和返回值中，在参数中使用指针也可以，但引用更为简洁。在函数内部通过修改参数中的引用来达到修改函数外部变量的目的。当返回一个引用时，必须同返回一个指针一样注意，和一个引用相关联的存储空间在函数返回时不会消亡，否则将引用到一个未知空间。引用在函数参数传递和返回中的语法和按值传递参数和返回的语法类似，但其区别在于，按值的方式传递或返回自定义对象时会调用构造函数和析构函数，而引用只需传递或返回地址。</p>
<p>当const限定的引用作为函数的参数时，对于内部类型，意味着在函数中不能够通过引用修改函数外部的变量，而对于自定义类型，则在该函数内只能调用const成员函数，而且不能够改变任何公共的数据成员。在函数参数中使用const引用特别重要，因为我们的函数也会接受临时对象，这个临时对象可能是另一个函数的返回值或由函数使用者显式建立的，临时变量总是const的，修改它没有任何意义。</p>
<p>2）拷贝构造函数</p>
<p>当按值的方式向函数传递或从函数返回内置类型时，传递时直接拷贝，函数返回时可以将其返回值放到寄存器中。而当传递或返回自定义对象时，传递时仍是直接拷贝，返回时寄存器没有足够大的空间存放整个对象，而是将返回值的目的地址像一个函数参数一样压栈，让函数直接把返回值拷贝到目的地址，这些地方对对象的拷贝就需要拷贝构造函数。</p>
<p>这里就有这样一个问题，如果是像a =f();这样的方式调用函数，那么可以将a的地址压栈，f()返回时直接将返回值拷贝到a中，但如果像f();这样调用函数，f()的返回值又会去哪呢？编译器为了计算一个表达式，而创建一个看不见的临时对象作为函数的返回的目的地址，这个临时对象的生存周期应当尽量的短。在一些情况下，临时变量会传递给其它的函数，但像f();这样的情况，一旦函数调用结束就对临时对象就被析构了。</p>
<p>在没有提供拷贝构造函数时，编译器会自动的完成拷贝，但编译器所做的仅仅是位拷贝，就是从一个空间拷贝到另一个空间，这样的拷贝是没有调用构造函数的，这会造成构造函数调用与析构函数调用的不对称，而且C++中的对象比一组比特位要复杂的多，对象具有含义，比如一个对象的一个数据成员是一个指针时，这时的对象拷贝就要求我们需要考虑更多，而不是仅仅的位拷贝（后面会讨论这个问题）。</p>
<p>当自定义了拷贝构造函数，那么编译器的自动拷贝就无效了。对于使用组合和继承的方法创建的类创建拷贝构造函数，编译器递归的为所有的成员和基类调用拷贝构造函数。如果成员对象还有别的对象，那么后者的拷贝构造函数也将被调用。</p>
<p>拷贝构造函数是仅当在按值传递对象或返回对象或用一个对象创建另一个对象时使用，如果不是这样的情况就不需要。可以通过将拷贝构造函数私有声明，这样就可以防止前面的情况出现（7小节3）中有一个拷贝构造函数私有声明的一个例子）。</p>
<p>3）指向成员的指针</p>
<p>C++提供了一种对对象共有成员的一种灵活的访问方式，这就是指向成员的指针。下面先看两个例子，指向数据成员和函数成员的指针例子。</p>
<p>例1：指向数据成员的指针</p>
<pre>
class Data {
public:
    int a, b, c;
    void print() const {
          cout &lt;&lt; "a="&lt;&lt;a&lt;&lt;"b="&lt;&lt; b &lt;&lt;"c="&lt;&lt; c&lt;&lt;endl;
    }
};
 
int main(void) {
    Data d, *dp = &d;
    int Data::*pmInt = &Data::a;
    dp->*pmInt = 47;
    pmInt = &Data::b;
    dp.*pmInt = 48;
    pmInt = &Data::c;
    dp->*pmInt = 49;
    dp->print();
}
</pre>
<p>例2：指向函数成员的指针</p>
<pre>
class Widget {
    void f(int) const {cout &lt;&lt; "f(int)"&lt;&lt; endl;}
    void g(int) const {cout &lt;&lt; "g(int)"&lt;&lt; endl;}
    void h(int) const {cout &lt;&lt; "h(int)"&lt;&lt; endl;}
    void i(int) const {cout &lt;&lt; "i(int)"&lt;&lt; endl;}
    enum {cnt = 4};
    void (Widget::*fptr[cnt])(int) const;
public:
    Widget() {
          fptr[0] = &Widget::f;//&Widget::f这种格式是语法需要的
          fptr[1] = &Widget::g;
          fptr[2] = &Widget::h;
          fptr[3] = &Widget::I;
    }
    void select(int i, in j) {
          if(i&lt;0 || i>=cnt)return;
          (this->*fptr[i])(j);//this->语法需要
    }
    int count() {return cnt;}
};
 
int main(void) {
    Widget w;
    for(int i=0; i&lt;w.count(); i++) {
          w.select(i, 47);
    }
}
</pre>
<p>从上面的例子中可以看出指向成员的指针使得访问对类的公有成员的方式变得灵活，可以在运行时改变操作，通过在运行时修改指向成员的指针的指向来选择类中的共有数据或函数成员，这就为程序设计提供了重要的灵活性。</p>
<p>指向成员的指针需要给出精确的指向，这种方式使得它显的过于难用，另外指向成员的指针是受限制的，它们仅能被指定给类中的确定位置，我们不能像使用普通指针那些增加或比较指针。</p>
<p>特别地，用typedef定义一个指针类型可以减少表达式的复杂度。</p>
<p><h4>9. 运算符重载</h4></p>
<p>运算符只是一种语法上的方便，也就是另外一种函数的调用方式，这种函数调用的参数不在()中，而是在运算符的附近，由编译器决定调用哪个运算符函数。例如使用+做floating-point运算，编译器调用浮点运算的加法运算（一般插入内联代码，或浮点运算处理命令）。如果用+运算×××和浮点型，编译器调用一个特殊函数将int转换成float再调用浮点加法运算函数代码。</p>
<p>C++中可以创建自定义类的运算符，这就是运算符重载了。运算符重载的定义与普通函数一样，只是在函数名（运算符）前加上关键字operator。当编译器遇到合适的模式时会调用相应函数。</p>
<p>1）敬告和语法</p>
<p>不应该滥用运算符重载，它是一种语法上的方便，是另外一种调用函数的方式而已。因此只有涉及类的代码更易写，尤其是更易读时才有理由重载运算符。如果不是这样，就不要bother了。</p>
<p>仅在包含内置数据类型的表达式中的所有运算符是不可能改变的。我们不能重载如下运算符改变其行为：1&lt;&lt;4;1.414&lt;&lt;2;，只有包含了自定义类型的表达式才能有重载运算符。</p>
<p>定义重载运算符就像定义函数一样，只是该函数名字是operator@，@代表重载的运算符。函数参数列表中的个数取决于：运算符是一元还二元的；运算符被定义为全局函数还是成员函数。</p>
<p>2）可重载的运算符</p>
<p>可重载的一元运算符有：+，-，~，*，&，!，++，--。其中重载的++和—运算符，是通过函数参数的不同区分前缀或后缀的。编译器会为int参数传递一个亚元变量值来为后缀版本产生不同的标记。</p>
<p>可重载的二元运算符有：+，-，*，%，/，^，&，|，&lt;&lt;，>>和=，+=，-=，*=，%=，/=，^=，&=，|=，&lt;&lt;=，>>=和==，!=，>，<，>=，<=，&&，||。其中和%，/相关的运算符重载函数中要考虑除数为0的情况（例如assert（））。</p>
<p>3）参数和返回值</p>
<p>对于重载运算符函数的参数传递和返回方式是遵循一种合乎逻辑的模式。</p>
<p>对于参数的传递，普通运算符（+，-，~，&，!）和布尔运算符不会改变参数，所以const引用传递是主要传递方式。当函数是一个成员函数时，就转换成一个const函数。只有赋值相关运算符，为改变左参数值，因此左参数不是const，仍按地址传递。</p>
<p>返回值的类型取决于运算符的含义，如果运算符是为了产生一个新值，那么你要产生一个新的对象作为返回值（如+，-，……），这个对象为临时对象不能当做左值来处理，那么它就就要是const的。</p>
<p>赋值运算符会修改左边的参数，为了有像a=b=c;这样的表达式，赋值运算符会返回一个左参数的引用（返回对象的话，会调用构造函数，这很浪费资源），这个引用时const还是non const的取决于你的需求，如果为使(a=b).func();表达式可行，因此返回的是non const引用。</p>
<p>自增自减，无论前缀还后缀均修改了对象，所以这个对象不能做为常量类型。前缀只需要返回一个引用*this，而后缀必须通过传值方式返回。返回是const还是non const的就要就事论事了。</p>
<p>这里还有一个返回值优化的问题，例如ruturnInteger(left.i + right.i);与Integer tmp(left.i + right.i); return tmp;相比，前者高效，因为编译器知道仅仅返回这样一个对象，因此编译器直接在外部返回值的地方创建这个对象。而后者将发生三件事：创建tmp；拷贝tmp到外部返回值的存储单元里；tmp在作用域尾时析构。</p>
<p>4）不常用运算符</p>
<p>不常用运算符有：[]，new，delete，"，"，->，->*。</p>
<p>下表运算符operator[]，必须是成员函数并且它只接受一个参数。这个运算符返回一个引用，所以可以方便的用于等号左侧。运算符new和delete用于控制动态存储分配，并能按多种不同的方式进行重载，后面会讲到。</p>
<p>     operator，只是对象间的隔开符，而不是函数参数中的或变量声明中的。下面是operator，的一个例子：</p>
<pre>
class After{
public:
    constAfter& operator,(const After&) const {
        return *this;
    }
};
 
class Before {};
Before& operator,(int, Before& b) {
    return b;
}
 
int main(void) {
    After a, b;
    a,b;   //operator comma called
    Before c;
    1,c;   //operator comma called
}
</pre>
<p>operator->在希望对象表现的像一个指针时，通常就要用到。如果想用类包装一个指针以使指针安全，或是在迭代器通用的用法中，这样做会特别有用。迭代器是一个对象，这个对象可以在其它对象的容器或者集合上移动，而不用对容器进直接的访问。</p>
<p>指针间接运算符一定是一个成员函数，它必须返回一个对象（或对象引用），该对象也有一个指针间接运算符；或者必须返回一个指针，被用于选择指针间接引用运算符箭头所指向的内容。下面是一个例子（指针间接运算符返回的是指针）：</p>

<pre>
class Obj {
    static int i, j;
public:
    voidf() const {cout &lt;&lt; i++ &lt;&lt; endl;}
    voidg() const {cout &lt;&lt; j++ &lt;&lt; endl;}
};
int Obj::i;
int Obj::j;
class ObjContainer {
    vector&lt;Obj*>a;
public:
    void add(Obj* obj) {
        a.push_back(obj);
    }
    class SmartPointer;
    friend SmartPointer;
    class SmartPointer {
        ObjContainer &oc;
        unsignedint index;
public:
    SmartPointer(ObjContainer&objc) : oc(objc) {index = 0;}
    bool operator++() {
        if(index>= oc.a.size()) return false;
        if(oc.a[++index]== 0) return false;
        return true;
    }
    bool operator++(int) {
        return operator++();
    }
    Obj* operator->() const {
        if(oc.a[index]== 0) return null;
        return oc.a[index];
    }
    };
    SmartPointer begin() {
        return SmartPointer(*this);
    }
};
int main(void) {
    constin sz = 100;
    Objo[sz];
    ObjContainer oc;
    for(inti=0; i&lt;sz; i++)
        oc.add(&o[i]);
    ObjContainer::SmartPointer sp = oc.begin();
    do{
        sp->f();
        sp->g();
    }while(++sp);
}
</pre>

<p> operator->*是一个二元运算符，它是专门为模仿前面介绍的指向成员的指针。（1）和operator->一样，指向成员的指针间接运算符通常同某种代表smartpointer的对象一起使用；（2）在定义operator->*时要注意它必须返回一个对象，对于这个对象，可以用正在调用的成员函数为参数调用operator()；（3）operator()函数的调用必须是成员函数，它是唯一的允许在它里面有任意个参数的函数，这使得对象看起来像一个真正的函数，从重载operator->*的和未重载的比较可以看出，->*和对象连接在一起了，使得对象在运行时可以改变操作；（4）要创建一个operator->*，必须首先创建带有operator()的类，这是operator->*将返回的类型，该类必须获取一些必要的信息，以使当operator被调用时，指向的成员的指针可以对对象进行间接调用。</p>
<p>下面是一个例子：</p>
<p></p>

<pre>
class Dog{
public:
    int run(int i) const {
        return i;
    }
    int eat(int i)const {
        return i;
    }
    int sleep(int i)const {
        return i;
    }
    typedef int(Dog::*PFM)(int) const;
    //operator->*must return an object that has an operator()
    class FunctionObject {
        Dog* ptr;
        PFM pmem;
public:
    FunctionObject(Dog*mp, PMF pmf) :ptr(mp), pmem(pmf) {}
    //make the call using the objectpointer and member pointer
    int operator()(int i) const {
        return (ptr->*pmem)(i);//call
    }
    };
    FunctionObject operator->*(PMF pmf) {
        return FunctionObject(this, pmf);
    }
};

int main(void) {
    Dogw;
    Dog::PMFpmf = &Dog::run;
    cout&lt;&lt; (w->*pmf)(1) &lt;&lt; endl;
    pmf= &Dog::eat;
    cout&lt;&lt; (w->*pmf)(2) &lt;&lt; endl;
    pmf =&Dog::sleep;
    cout&lt;&lt; (w->*pmf)(3) &lt;&lt; endl;
}
</pre>

<p>一段英文原文：</p>
<p>Notice that whatyou are doing here, just as with operator->, is inserting yourself in themiddle of the call to operator->*. This allows you to perform some extra operations if you need to.</p>
<p>5）不能重载的运算符</p>
<p>成员选择运算符operator.，点在类中对任何成员都有一定的意义。如果允许重载它，就不能用普通的方法访问成员，只能用指针和operator->访问。</p>
<p>成员指针间接引用operator.*，因为与operator.同样的原因而不能重载。</p>
<p>没有幂运算符，可以用函数实现。</p>
<p>不存在用户自定义的运算符，不这样做的原因是难以决定其优先级，另也没有必要增加麻烦。</p>
<p>不能改变优先级规则，否则很难记住他们。</p>
<p>6）非成员运算符</p>
<p>有时候重载运算符时需要使左操作数是另一个类的对象，这样就需要将运算符重载函数放到类的外部，而在类中声明其为friend。常见的地方是重载运算符&lt;&lt;和>>为iostreams。由于iostreams是一个基础C++库，你很肯能回想为你自己的类而重载这些运算符。</p>
<p>7）Basic guidelines</p>
<pre>
Operator                    Recommended use
All unary operators         Member
=，()，->，->*              Must be member

+=，-=，*=，%=，/=，
^=，&=，|=，&gt;&gt;=，&lt;&lt;=        Member

All other binary operators  Non-member
</pre>
<p>8）赋值运算符重载</p>
<p>先看这样几个表达式：MyType b;MyType a = b; a = b;。在第一个=是调用的拷贝构造函数，第二个=才调用的赋值运算符。</p>
<p>前面讲过operator=只能是成员函数，它是和"="左边的对象紧密联系的。如果可以将operator定义为全局的，那么你就可能会定义内置的"="：int operator=(int, MyType);//not allowed。</p>
<p>当你创建一个operator=，你必须从右边拷贝所有需要的信息到当前对象（调用运算符对象）以完成类的"赋值"，对于简单对象这是显然的。operator=返回一个引用，使得更复杂的表达式能够实现（=结合方向从右到左）。同样operator&lt;&lt;类似，但结合方向左到右。</p>
<p>operator=函数中一定要检测自我赋值，因为当类的实现修改了，可能会引起对象的改变，如果没有检查，可能会出现一个很难找的bug。</p>
<p>如果没有创建自己的operator=，编译器将自动创建一个，这个运算符模仿自动创建的构造函数：如果包含对象（或从别的类继承而来），对于这些对象，operator=被递归调用，这被称作memberwise assignment。 </p>
<p>9）运行时拷贝</p>
<p>当类中包含了一个其它类型的指针时，如果简单的拷贝一个指针，就会出现两个对象同时指向一个空间，要解决这个问题就要自己标记了。这样的话对于一个含有其它类型指针的类来说，类中有四个函数要定义：必要的构造函数、拷贝构造函数、operator=（either define it or disallow it）和析构函数。下面是一个解决自己标记问题的例子，采用的是引用计数的方法，又叫做运行时拷贝：</p>
<p></p>

<pre>
class Dog {
    string name;
    int refcount;
    Dog(const string& name) : name(name), refcount(1) {}
    //Prevent assignment:
    Dog& operator=(const Dog&);
public:
    //Dogs can only be created on the heap:
    static Dog* make(const string& name) {
        return new Dog(name);
    }
    Dog(const Dog& d) : name(d.name), refcount(1) {}
    ~Dog() {}
    void attatch() {
        refcount++;
    }
    void detatch() {
        assert(refcount != 0);
        if(--refcount == 0) delete this;
    }
    Dog* unalias() {
        if(refcount ==1) return this;
        --refcount;
        return newDog(*this);
    }
    void rename(const string& newname) {
        name = newname;
    }
};

class DogHouse {
    Dog*p;
    string housename;
    void unalias() {
        p = p->unalias();
    }
public:
    DogHouse(Dog* dog, const string& house) : p(dog),housename(house) {}
    DogHouse(const DogHouse& dh) : p(dh.p),housename(dh.housename) {
        p->attatch();
    }
    DogHouse& operator=(const DogHouse& dh) {
        if(this == & dh) return dh;
        p->detatch();
        p = dh.p;
        housename = dh.housename;
        p->attatch();
        return *this;
    }
    ~DogHouse() {
        p->detatch();
    }
    void renamehouse(const string& newname) {
        housename= newname;
    }
    void renamedog(const string& newname) {
        unalias();
        p->rename(newname);
    }
    Dog* getdog() {
        unalias();
        return p;
    }
};
</pre>

<p>10）  自动类型转换</p>
<p>在C和C++中，如果编译器看到一个表达式和函数调用中使用了一个不合适的类型，它经常会执行一个自动类型转换，从现在的类型到所要求的的类型。在C++中可以通过定义自动类型转换函数来为用户自定义类型达到相同效果，有两种方式可以做：特殊类型的构造函数和重载运算符。</p>
<p>构造函数自动类型转换例子：</p>
<pre>
class One {
public:
    One(){}
};
class Two {
public:
    Tow(const One&) {}
};
void f(Two) {}
int main() {
    One one;
    f(one);//wantsa Two, has a One
}
</pre>
<p>在这个例子的情况下，自动类型转换避免了定义两个f()重载版本的麻烦。然而代价是调用Two的构造函数（隐藏调用），如果关系f()的效率，就不要使用这种方法。有时为了避免自动类型转换为用户带来麻烦，可以将自动类型转换的构造函数用explicit声明，这样编译器被告知不能使用该构造函数执行任何自动类型转换。如果用户想进行转换就必须写出代码如:f(Tow(one))。</p>
<p>重载运算符转换例子：</p>
<pre>
class Three {
    inti;
public:
    Three(intii=0; int=0) : i(ii) {}
};
class Four {
    intx;
public:
    Four(intxx) : x(xx) {}
    operatorThree() const {return Three(x);}
};
void g(Three) {}
int main(void) {
    Fourfour(1);
    g(four);
    g(1);  //calls Three(1,0)
}
</pre>
<p>用构造函数技术，目的类执行转换；而使用运算符技术，是源类执行转换。</p>
<p>使用全局运算符而不用成员运算符最大的好处是在全局版本中的自动类型转换可以针对左右任一操作数。如果想两个操作数都被转换，全局运算符重载可以节省很多代码，下面是一个例子：</p>
<pre>
class Number {
    intI;
public:
    Number(intii=0) : i(ii) {}
    constNumber operator+(const Number& n) const {
         returnNumber(i + n.i);
}
friend constNumber operator-(const Number& n);
}
const Number operator-(const Number&n1, const Number& n2) {
    returnNumber(n1.i – n2.i);
}
int main(void) {
    Numbera(30), b(23);
    a+b;//ok
    a+1;//2ndarg converted to Number
    //!1+a;//Wrong! 1st arg not of type Number
a-b;//ok
a-1;//2ndarg converted to Number
1-a;//1starg converted to Number
}
</pre>
<p>当类中含有一个字符串时，那自动类型转换就显得非常有用。如果没有自动类型转换，那么要用到C库中的字符串处理函数，就必须为库中的每个函数创建成员函数，就像下面的例子一样：</p>
<pre>
class Stringc {
    strings;
public:
    Stringc(conststring& str="") : s(str) {}
    intstrcmp(const string& str) const {
         return::strcmp(s.c_str(), str.s.c_str());
    }
    //……ect.,forevery function in cstring.h
};
</pre>
<p>但是如果提供一个自动类型转换，就能够使用<cstring>中的所有函数，如下例子：</p>
<pre>
class Stringc {
    strings;
public:
    Stringc(conststring& str="") : s(str) {}
    operatorconst char*() const {
         returns.c_str();
    }
};
int main() {
    Stringcs1("Hello"), s2("there");
    strcmp(s1,s2);  //sdandard c function
}
</pre>
<p>自动类型转换也有它的缺陷，当在源类型和目的类型中都含有相同功能的自动类型转换是，编译器就不知道调用哪一个。最好提供单一的从一个类型到另一个类型的自动转换方法。</p>
<p>当类提供了不止一种类型的自动转换时，会发生一个很难发现的错误，假如一个Apple类，它提供了向Orange类型和Pear类型的自动转换，而又在类的外部定义了两个重载函数，如void eat(Orange){} 和void eat(Pear){}，那么当有表达式Apple c; eat(c);时，编译器会调用两个重载函数中的哪一个呢？</p>
<p>通常对于自动类型转换的解决方法是，只是提供一个从某类型像另一个类型转换的自动类型转换版本。当然也可以有多个向其他类型的转换，但它们不应该是自动转换，而是应该用如makeA()和makeB这样的名字来显式的调用函数，也可以使用目的类型中的explicit构造函数来解决。</p>
<p>自动类型转换还有一个隐藏的行为，先看下面的例子：</p>
<pre>
class Fi {};
class Fee {
    Fee(int){}
    Fee(constFi&) {}
};
class Fo {
    inti;
public:
    Fo(intx=0) i(x) {}
    operatorFee() const {
         returnFee(i);
    }
};
int main(void) {
    Fofo;
    Feefee = fo;
}
</pre>
<p>在用fo对象去初始化fee对象的时候，Fo类中的向Fee自动类型转换函数被调用，然而在Fee类中没有用Fee类型的对象去初始化一个Fee对象的拷贝构造函数，那么编译器将创建这样的一个函数。</p>
<p>自动类型转换应当小心使用。同所有的重载运算符相比，它在减少代码方面是非常出色的，但不值得无缘无故的使用。</p>
<p> </p>
<p><h4>10.动态对象创建</h4></p>
<p>在C中我们使用malloc和free在运行时从堆中分配和释放存储单元。malloc和free是用到操作系统提供的系统调用来实现的，它从堆里搜索一块足够大的内存来满足请求（这个过程可能很快，也可能要试探几次，因此每次运行malloc的时间是不一样的），并在返回分配的内存的地址和大小记录下来，这样以后调用malloc就不会使用它，而且当调用free释放这块内存时，系统就知道在哪释放多大的内存。</p>
<p>但是malloc和free在C++中不能很好的工作，原因是在C++中一块内存被分配后，C++总是试图去初始化它，而当一块内存不需要的时候，总是先析构然后释放存储空间。我们知道在C++中构造函数和析构函数的调用都是由编译器完成的，编译器会将一块存储空间的地址隐式的传递给构造函数或析构函数。如果malloc和free在C++使用，那么意味着用户自己就要向构造函数或析构函数传递存储单元的地址，这样是不安全的，因为用户不能保证每次都能够操作正确，因而应该将存储空间的分配和初始化、析构和存储空间的释放放在一起，使他们成为一个机械的步骤，这样的话就应该把动态对象创建和释放交给编译器来做，成为语言的核心。</p>
<p>1）new和delete</p>
<p>当用new运算符动态的创建一个对象时，有两件事发生了，存储空间的分配以及构造函数的调用。new使得在堆中创建对象的过程变得简单了，它带有内置的长度计算，类型转换和安全检查。</p>
<p>delete用于释放一个动态创建的对象，调用delete时也有两件事发生，析构函数调用，释放存储空间。如果删除的对象的指针是0，将不发生任何事情。为此，建议在删除指针后立即把指针赋值为0以避免对它删除多次，对一个对象删除多次可能会产生某些问题。delete一个指针的时候需要知道该指针的类型，如果delete一个void指针那么就仅仅释放了存储空间，而没有调用析构函数，这样的话，如果一个对象的数据成员中有指针，那么仅仅释放了存储指针的存储空间，而指针指向的空间就没有释放（这个过程应该在析构函数中完成的）。</p>
<p>new和delete也可用于数组，当new用于数组时，动态申请了多少个对象，就会调用构造函数多少次。除了在栈上的集合初始化外，在堆上的数组创建，必须有一个默认的构造函数，因为没有参数的构造函数必须为每个对象调用。释放动态数组时，使用delete[]，这个[]告诉编译器生成取出数组中对象个数的代码，然后调用那么多个数的析构函数。</p>
<p>2）内存耗尽时的动作</p>
<p>当operatornew()找不到足够大的连续内存块时，一个new-handler的特殊函数将会被调用，或者更常用的是用自定义的new-handler函数。new-handler默认动作是产生一个异常，然而如果我们在堆分配，至少要用"内存耗尽"的信息代替new-handler，并异常中断程序。</p>
<p>通过包含new.h来替换new-handler，然后以想装入的函数地址为参数调用set_new_handler()函数。下面是一个例子：</p>
<pre>
#include&lt;iostream>
#include&lt;cstdlib>
#include&lt;new>
using namespace std;
int count = 0;
void out_of_memory() {
    cerr&lt;&lt; "Memory exhausted after" &lt;&lt;
         &lt;&lt;count&lt;&lt;"allocations"&lt;&lt;endl;
    exit(1);
}
int main(void) {
    set_new_handler(out_of_memory);
    while(1){
         count++;
         newint[1000]; //exhausts memory
    }
}
</pre>
<p>new-handler函数必须不带参数且其返回值为void。new-handler的行为是与operatornew紧密联系的，所以如果重载了operator new，那么new-handler将不会按默认调用。如果仍想调用new-handler，则我们不得不在重载了的operator new()的代码中加上做这些工作的代码。</p>
<p>当然可以写更复杂的new-handler，甚至它可以回收内存。</p>
<p>3）重载new和delete</p>
<p>使用C++内置的new和delete在一些特殊的情况下并不能满足需求，最常见的是出于对效率的考虑，比如当要创建和销毁一个特定类的非常多的对象以至于new和delete的存储空间分配方案成了程序效率的瓶颈的时候；另一个问题是堆碎片的问题，分配不同大小的内存可能会在堆上产生很多碎片，以至于很快用完内存。C++提供了对new和delete重载的支持，这样我们就可以改变原有的分配方法，编译器将用重载的new代替默认的版本去分配内存，然后调用构造函数，但重载new也仅仅改变了内存分配部分，delete也是类似的。</p>
<p>当重载new时，也就替换了当内存消耗殆尽的行为，所以必须在operatornew()里决定做什么：返回0，写一个调用new-handler的循环试着再分配，或者产生一个bad-alloc的异常。</p>
<p>（1）      重载全局new和delete</p>
<p>对全局版本的new和delete重载，就意味着默认版本完全不能被访问，甚至在这个从新定义的版本里也不能访问它。</p>
<p>重载的new必须有一个size_t的参数（sizes的标准C类型）。这个参数由编译器产生并传递给我们，它是要分配内存的长度。operator new()的正常返回值是一个void*指针，而不是指向特定类型的指针，因为在这里做的仅仅是内存分配，要在构造函数调用（编译器的工作）完成后，才完成了对象的创建。operator delete()的参数是一个有operator new()分配的内存的void*。参数是一个void*，是对对象析构后的到的指针。operator deleted()返回类型是void。</p>
<p>下面是一个例子：</p>
<pre>
#include &lt;cstdio>
#include &lt;cstdlib>
using namespace std;
void* operator new(size_t sz) {
    printf("operatornew : %dBytes\n", sz);
    void*m = malloc(sz);
    if(!m)puts("out of memory");
    returnm;
}
void operator delete(void* m) {
    puts("operatordelete\n");
    free(m);
}
class S {
    inti[100];
public:
    S(){puts("S::S()\n");}
    ~S(){puts("S::~S()\n");}
};
int main(void) {
    puts("Creating& destroying an int\n");
    int*p = new int(56);
    deletep;
    puts("Creating& destroying an S\n");
    S*s = new S;
    deletes;
    puts("Creating& destroying S[3]\n");
    S*sa = new S[3];
    delete[]sa;
}
</pre>
<p>在main中的对内部类型，自定义类型以及数组的创建和销毁均使用了全局重载版本的new和delete。</p>
<p>（2）      对于一个类重载new和delete</p>
<p>为一个类重载new和delete时，尽管不必显式使用static，但实际上仍是在创建static成员函数。当编译器看到使用new创建自定义的类的对象时，它选择成员版的operator new()而不是全局版本。但全局版本的new和delete仍为所有其它类型对象使用，除非他们有自己的new和delete。</p>
<p>下面是一个例子：</p>
<pre>
class Framis {
    enum{sz = 10};
    charc[sz]; //just for space taken
    static unsigned char pool[];
    static bool alloc_map[];
public:
    enum{psize = 100};
    Framis(){}
    ~Framis(){}
    void* operator new(size_t) throw(bad_alloc);
    void operator delete(void*);
};
unsigned charFramis::pool[psize*sizeof(Framis)];
boll Framis::alloc_map[psize]= {false};
 
void* Framis::operator new(size_t) throw(bad_alloc){
    for(inti=0; i&lt;psize; i++) {
         if(!alloc_map[i]){
             alloc_map[i]= true;
             returnbool+(i*sizeof(Framis));
         }
    }
    throwbad_alloc();
}
 
void operator delete(void* m) {
    if(!m)return;
    unsignedlong block = (unsigned long)m-(unsigned long)pool;
    block/= sizeof(Framis);
    alloc_map[block]= false;
}
</pre>
<p>在这个例子中无论何时我们动态的创建单个的Framis对象（而不是数组），都将调用局部的operator new()。而全局版本的new()在创建数组时使用。因此用户在用operator delete删除一个数组时，偶然的忘记了使用[]语法，而这就会出现问题，这样就调用了局部版本的delete，而在上面的例局部版本的delete删除的一块静态内存。如果考虑这样的事情，那么在局部版本的delete中应该加入检查删除指针的地址是否在该类的这块静态内存范围内，这样重载new和delete也可以用于检查代码中的内存泄露。</p>
<p>（3）      为数组重载new和delete</p>
<p>重载operator new[]和operatordelete[]，来控制对对象数组的分配。下面是一个例子：</p>
<pre>
class Widget {
    enum{sz = 10};
    inti[sz];
public:
    Widget(){}
    ~Widget(){}
    void*operator new(size_t sz) {
        return ::new char[sz];
    }
    voidoperator delete(void* p) {
         ::delete[]p;
    }
    void*operator new[](size_t sz) {
         return::new char[sz];
    }
    voidoperator delete[](void* p) {
         ::delete[]p;
    }
};
</pre>
<p>operator new[]()和operatordelete[]()只为整个数组调用一次，但对于数组中的每一个对象，都调用了默认构造函数和析构函数。</p>
<p>（4）      构造函数调用</p>
<p>如果new的内存分配没有成功，将会出现什么状况呢？在这种情况下，构造函数将不会被调用，所以虽然没有成功的创建对象，但至少没有调用构造函数并传给它一个为0的this指针。</p>
<p>4）定位new和delete</p>
<p>有时候我们想在一个指定内存的位置上放置一个对象或是我们想在调用new时，能够选择不同的内存分配方案。这两个特性可以用在重载operator new时多带一个参数，放置对象的地址的参数。下面是一个例子：</p>
<pre>
class X {
    inti;
public:
    X(intii=0) : i(ii) {}
    ~X(){}
    void*operator new(size_t, void* loc) {
         returnloc;
    }
};
int main(void) {
    intl[10];
    X*xp = new(l)X(34); //X location at l
    xp->X::~X();//Explict destructor call, and this is only used for placement
}
</pre>
<p>main中的这种显式的调用析构函数的方法，其实就是为支持operator new的定位而形成的。</p>


<p style='float:right;'>本页共819段，34141个字符，65231 Byte(字节)</p>﻿




</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>
