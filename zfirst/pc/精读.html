<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>

<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:40em;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h3{
	font-size:1.1em;
	font-weight:bold;
	text-indent:0em;
	color:#990000;
}
h4{
	font-size:1.0em;
	font-weight:bold;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:5px;
	margin-left:2em;
	background-color:RGB(240,240,240);
    color:blue;
	margin-left:2em;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
pre{
    margin-left:2em;
    width:115%;
    overflow-x:auto;
	}
a:visited, a:link{
    color:blue;
}
a:visited{
    color:#CC0000;
}a:hover{
    color:green;
	}
</style>
</head>

<body>

<div id="container">
    <p align="left"><strong>前端之路 </strong></p>

<p>记录前端成长的点滴 </p>
    <p align="left"><strong><a href="https://www.zhihu.com/people/huang-zi-yi-83" target="_blank">黄子毅</a></strong></p>



<p><strong><a href="https://zhuanlan.zhihu.com/p/558894211" target="_blank">精读《SolidJS》</a></strong></p>

<p><strong><a href="https://link.zhihu.com/?target=https%3A//github.com/solidjs/solid" target="_blank">SolidJS</a></strong>&nbsp;是一个语法像 React Function Component，内核像 Vue 的前端框架，本周我们通过阅读&nbsp;<strong><a href="https://link.zhihu.com/?target=https%3A//www.loginradius.com/blog/engineering/guest-post/introduction-to-solidjs/" target="_blank">Introduction  to SolidJS</a></strong>&nbsp;这篇文章来理解理解其核心概念。 为什么要介绍  SolidJS 而不是其他前端框架？因为 SolidJS 在教  React 团队正确的实现 Hooks…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/556348001" target="_blank">精读《对前端架构的理解 - 分层与抽象》</a></strong></p>

<p>可能一些同学会认为前端比较简单而不需要架构，或者因为前端交互细节杂而乱难以统一抽象，所以没办法进行架构设计。这个理解是片面的，虽然一些前端项目是没有仔细考虑架构就堆起来的，但这不代表不需要架构设计。任何业务程序都可以通过代码堆砌的方式实现功能，但背后的可维护性、可拓展性自然也就千差万别了。  为什么前端项目也要考虑架构设计…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/553804414" target="_blank">精读《pnpm》</a></strong></p>

<p><strong><a href="https://link.zhihu.com/?target=https%3A//pnpm.io/" target="_blank">pnpm</a></strong>&nbsp;全称是 “Performant NPM”，即高性能的 npm。它结合软硬链接与新的依赖组织方式，大大提升了包管理的效率，也同时解决了 “幻影依赖” 的问题，让包管理更加规范，减少潜在风险发生的可能性。  使用 pnpm 很容易，可以使用 npm 安装： npm i pnpm -g 之后便可用 pnpm 代替 npm…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/551040025" target="_blank">精读《Unique, MapTypes, Construct Tuple...》</a></strong></p>

<p>解决  TS 问题的最好办法就是多练，这次解读&nbsp;<strong><a href="https://link.zhihu.com/?target=https%3A//github.com/type-challenges/type-challenges" target="_blank">type-challenges</a></strong>&nbsp;Medium  难度 63~68 题。&nbsp;<strong>精读</strong>&nbsp;<strong><a href="https://link.zhihu.com/?target=https%3A//github.com/type-challenges/type-challenges/blob/main/questions/05360-medium-unique/README.md" target="_blank">Unique</a></strong>&nbsp;实现 Unique&lt;T&gt; ，对 T 去重： type Res = Unique&lt;[1, 1, 2, 2, 3, 3]&gt; // expected to be [1,  2,…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/548417676" target="_blank">精读《Trim Right, Without, Trunc...》</a></strong></p>

<p>解决  TS 问题的最好办法就是多练，这次解读&nbsp;<strong><a href="http://link.zhihu.com/?target=https%3A//github.com/type-challenges/type-challenges" target="_blank">type-challenges</a></strong>&nbsp;Medium  难度 57~62 题。&nbsp;<strong>精读</strong>&nbsp;<strong><a href="http://link.zhihu.com/?target=https%3A//github.com/type-challenges/type-challenges/blob/main/questions/04803-medium-trim-right/README.md" target="_blank">Trim Right</a></strong>&nbsp;实现 TrimRight 删除右侧空格：&nbsp;type Trimed =  TrimRight&lt;' Hello World '&gt; // expected to be '…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/545696318" target="_blank">精读《Flip, Fibonacci, AllCombinations...》</a></strong></p>

<p>解决  TS 问题的最好办法就是多练，这次解读&nbsp;<strong><a href="http://link.zhihu.com/?target=https%3A//github.com/type-challenges/type-challenges" target="_blank">type-challenges</a></strong>&nbsp;Medium  难度 49~56 题。&nbsp;<strong>精读</strong>&nbsp;<strong><a href="http://link.zhihu.com/?target=https%3A//github.com/type-challenges/type-challenges/blob/main/questions/04179-medium-flip/README.md" target="_blank">Flip</a></strong>&nbsp;实现 Flip&lt;T&gt; ，将对象 T 中 Key 与 Value 对调：&nbsp;Flip&lt;{  a: &quot;x&quot;, b: &quot;y&quot;, c: &quot;z&quot; }&gt;; // {x: 'a', y: 'b…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/542859635" target="_blank">精读《ObjectEntries, Shift, Reverse...》</a></strong></p>

<p>解决  TS 问题的最好办法就是多练，这次解读&nbsp;<strong><a href="http://link.zhihu.com/?target=https%3A//github.com/type-challenges/type-challenges" target="_blank">type-challenges</a></strong>&nbsp;Medium  难度 41~48 题。&nbsp;<strong>精读</strong>&nbsp;<strong><a href="http://link.zhihu.com/?target=https%3A//github.com/type-challenges/type-challenges/blob/main/questions/02946-medium-objectentries/README.md" target="_blank">ObjectEntries</a></strong>&nbsp;实现 TS 版本的 Object.entries ：&nbsp;interface Model { name: string; age: number; locations: s…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/540032187" target="_blank">精读《MinusOne, PickByType, StartsWith...》</a></strong></p>

<p>解决  TS 问题的最好办法就是多练，这次解读&nbsp;<strong><a href="http://link.zhihu.com/?target=https%3A//github.com/type-challenges/type-challenges" target="_blank">type-challenges</a></strong>&nbsp;Medium  难度 33~40 题。&nbsp;<strong>精读</strong>&nbsp;<strong><a href="http://link.zhihu.com/?target=https%3A//github.com/type-challenges/type-challenges/blob/main/questions/02257-medium-minusone/README.md" target="_blank">MinusOne</a></strong>&nbsp;用 TS 实现 MinusOne 将一个数字减一：&nbsp;type Zero = MinusOne&lt;1&gt; // 0 type FiftyFour =  MinusOne&lt;55&amp;g…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/537207402" target="_blank">精读《Diff, AnyOf, IsUnion...》</a></strong></p>

<p>解决  TS 问题的最好办法就是多练，这次解读&nbsp;<strong><a href="https://link.zhihu.com/?target=https%3A//github.com/type-challenges/type-challenges" target="_blank">type-challenges</a></strong>&nbsp;Medium  难度 25~32 题。&nbsp;<strong>精读</strong>&nbsp;<strong><a href="https://link.zhihu.com/?target=https%3A//github.com/type-challenges/type-challenges/blob/main/questions/00645-medium-diff/README.md" target="_blank">Diff</a></strong>&nbsp;实现 Diff&lt;A, B&gt; ，返回一个新对象，类型为两个对象类型的 Diff： type Foo = { name: string age: string } type Bar…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/534209521" target="_blank">精读《Permutation, Flatten, Absolute...》</a></strong></p>

<p>解决  TS 问题的最好办法就是多练，这次解读&nbsp;<strong><a href="https://link.zhihu.com/?target=https%3A//github.com/type-challenges/type-challenges" target="_blank">type-challenges</a></strong>&nbsp;Medium  难度 17~24 题。&nbsp;<strong>精读</strong>&nbsp;<strong><a href="https://link.zhihu.com/?target=https%3A//github.com/type-challenges/type-challenges/blob/main/questions/00296-medium-permutation/README.md" target="_blank">Permutation</a></strong>&nbsp;实现 Permutation 类型，将联合类型替换为可能的全排列： type perm =  Permutation&lt;'A' | 'B' | &amp;#…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/531111374" target="_blank">精读《Promise.all, Replace, Type Lookup...》</a></strong></p>

<p>解决  TS 问题的最好办法就是多练，这次解读&nbsp;<strong><a href="https://link.zhihu.com/?target=https%3A//github.com/type-challenges/type-challenges" target="_blank">type-challenges</a></strong>&nbsp;Medium  难度 9~16 题。&nbsp;<strong>精读</strong>&nbsp;<strong><a href="https://link.zhihu.com/?target=https%3A//github.com/type-challenges/type-challenges/blob/main/questions/00020-medium-promise-all/README.md" target="_blank">Promise.all</a></strong>&nbsp;实现函数 PromiseAll ，输入 PromiseLike，输出 Promise&lt;T&gt; ，其中 T 是输入的解析结果： const promiseAllTest1 = Pr…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/527971404" target="_blank">精读《Get return type, Omit, ReadOnly...》</a></strong></p>

<p>解决  TS 问题的最好办法就是多练，这次解读&nbsp;<strong><a href="https://link.zhihu.com/?target=https%3A//github.com/type-challenges/type-challenges" target="_blank">type-challenges</a></strong>&nbsp;Medium  难度 1~8 题。&nbsp;<strong>精读</strong>&nbsp;<strong><a href="https://link.zhihu.com/?target=https%3A//github.com/type-challenges/type-challenges/blob/main/questions/00002-medium-return-type/README.md" target="_blank">Get Return  Type</a></strong>&nbsp;实现非常经典的 ReturnType&lt;T&gt; ： const fn = (v: boolean) =&gt; { if (v) return 1 else…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/524723531" target="_blank">精读《type challenges - easy》</a></strong></p>

<p>TS 强类型非常好用，但在实际运用中，免不了遇到一些难以描述，反复看官方文档也解决不了的问题，至今为止也没有任何一篇文档，或者一套教材可以解决所有犄角旮旯的类型问题。为什么会这样呢？因为 TS 并不是简单的注释器，而是一门图灵完备的语言，所以很多问题的解决方法藏在基础能力里，但你学会了基础能力又不一定能想到这么用。  解决…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/521877733" target="_blank">精读《web reflow》</a></strong></p>

<p>网页重排（回流）是阻碍流畅性的重要原因之一，结合&nbsp;<strong><a href="http://link.zhihu.com/?target=https%3A//gist.github.com/paulirish/5d52fb081b3570c81e3a" target="_blank">What forces  layout / reflow</a></strong>&nbsp;这篇文章与引用，整理一下回流的起因与优化思考。 借用这张经典图： 网页渲染会经历 DOM -&gt; CSSOM -&gt; Layout(重排 or reflow)  -&gt; Paint(重绘) -&gt; Com…</p>



<p><strong><a href="https://zhuanlan.zhihu.com/p/518445295" target="_blank">精读《react-snippets - Router 源码》</a></strong></p>

<p>造轮子就是应用核心原理 + 周边功能的堆砌，所以学习成熟库的源码往往会受到非核心代码干扰，<strong><a href="http://link.zhihu.com/?target=https%3A//github.com/ashok-khanna/react-snippets/blob/main/Router.js" target="_blank">Router</a></strong>&nbsp;这个 repo 用不到  100 行源码实现了 React Router 核心机制，很适合用来学习。&nbsp;<strong>精读</strong>&nbsp;<strong><a href="http://link.zhihu.com/?target=https%3A//github.com/ashok-khanna/react-snippets/blob/main/Router.js" target="_blank">Router</a></strong>&nbsp;快速实现了 React Router 3 个核心 API： Router 、 navigate 、  Link ，…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/514962036" target="_blank">精读《React useEvent RFC》</a></strong></p>

<p>useEvent 要解决一个问题：如何同时保持函数引用不变与访问到最新状态。 本周我们结合&nbsp;<strong><a href="http://link.zhihu.com/?target=https%3A//github.com/reactjs/rfcs/blob/useevent/text/0000-useevent.md" target="_blank">RFC</a></strong>&nbsp;原文与解读文章&nbsp;<strong><a href="http://link.zhihu.com/?target=https%3A//typeofnan.dev/what-the-useevent-react-hook-is-and-isnt/" target="_blank">What the  useEvent React hook is (and isn't)</a></strong>&nbsp;一起了解下这个提案。 借用提案里的代码，一下就能说清楚 useEvent 是个什么东西：&nbsp;function Chat()…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/511389069" target="_blank">精读《JS 数组的内部实现》</a></strong></p>

<p>每个  JS 执行引擎都有自己的实现，我们这次关注&nbsp;<strong><a href="http://link.zhihu.com/?target=https%3A//v8.dev/" target="_blank">V8</a></strong>&nbsp;引擎是如何实现数组的。  本周主要精读的文章是&nbsp;<strong><a href="http://link.zhihu.com/?target=https%3A//blog.gauravthakur.in/how-javascript-array-works-internally" target="_blank">How  JavaScript Array Works Internally?</a></strong>，比较简略的介绍了 V8 引擎的数组实现机制，笔者也会参考部分其他文章与源码结合进行讲解。&nbsp;<strong>概述</strong>&nbsp;JS 数组的内部类型有很多模式，如： PACKED_…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/500359748" target="_blank">精读《不再需要 JS 做的 5 件事》</a></strong></p>

<p>关注  JS 太久，会养成任何功能都用 JS 实现的习惯，而忘记了  HTML 与 CSS 也具备一定的功能特征。其实有些功能用  JS 实现吃力不讨好，我们要综合使用技术工具，而不是只依赖 JS。&nbsp;<strong><a href="https://link.zhihu.com/?target=https%3A//lexoral.com/blog/you-dont-need-js/" target="_blank">5 things you  don't need Javascript for</a></strong>&nbsp;这篇文章就从 5 个例子出发，告诉我们哪些…</p>



<p><strong><a href="https://zhuanlan.zhihu.com/p/493624398" target="_blank">SQL grouping</a></strong></p>

<p>SQL grouping 解决 OLAP 场景总计与小计问题，其语法分为几类，但要解决的是同一个问题： ROLLUP 与 CUBE 是封装了规则的 GROUPING SETS，而 GROUPING SETS 则是最原始的规则。  为了方便理解，让我们从一个问题入手，层层递进吧。&nbsp;<strong>底表</strong>&nbsp;以上是示例底表，共有 8 条数据，城市1、城…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/488753832" target="_blank">SQL 窗口函数</a></strong></p>

<p>窗口函数形如：&nbsp;表达式 OVER (PARTITION BY 分组字段 ORDER BY 排序字段) 有两个能力： 当表达式为 rank() dense_rank() row_number() 时，拥有分组排序能力。 当表达式为 sum() 等聚合函数时，拥有累计聚合能力。 无论何种能力，<strong>窗口函数都不会影响数据行数，而是将计算</strong>…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/484492680" target="_blank">SQL CASE 表达式</a></strong></p>

<p>CASE 表达式分为简单表达式与搜索表达式，其中搜索表达式可以覆盖简单表达式的全部能力，我也建议只写搜索表达式，而不要写简单表达式。  简单表达式：&nbsp;SELECT CASE city WHEN '北京'  THEN 1 WHEN '天津' THEN 2 ELSE 0 END AS abc FROM test 搜索表达式：&nbsp;SEL…</p>



<p><strong><a href="https://zhuanlan.zhihu.com/p/480597670" target="_blank">SQL 复杂查询</a></strong></p>

<p>SQL 复杂查询指的就是子查询。 为什么子查询叫做复杂查询呢？因为子查询相当于查询嵌套查询，因为嵌套导致复杂度几乎可以被无限放大（无限嵌套），因此叫复杂查询。下面是一个最简单的子查询例子：&nbsp;SELECT pv FROM ( SELECT pv FROM test ) 上面的例子等价于 SELECT pv FROM te…</p>





<p><strong><a href="https://zhuanlan.zhihu.com/p/476883070" target="_blank">SQL 聚合查询</a></strong></p>

<p>SQL 为什么要支持聚合查询呢？ 这看上去是个幼稚的问题，但我们还是一步步思考一下。数据以行为粒度存储，最简单的 SQL 语句是 select * from test ，拿到的是整个二维表明细，但仅做到这一点远远不够，出于以下两个目的，需要 SQL 提供聚合函数： 明细数据没有统计意义，比如我想知道今天的营业额一共有多少，而…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/473403110" target="_blank">SQL 入门</a></strong></p>

<p>本系列是 SQL 系列的开篇，介绍一些宏观与基础的内容。&nbsp;<strong>SQL </strong><strong>是什么？</strong>&nbsp;SQL 是一种结构化查询语言，用于管理关系型数据库，我们 90% 接触的都是查询语法，但其实它包含完整的增删改查和事物处理功能。&nbsp;<strong>声明式特性</strong>&nbsp;SQL 属于声明式编程语言，而现代通用编程语言一般都是命令式的。但是不要盲目崇拜声明式语言，比如说它未来会代替…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/470082866" target="_blank">精读《对 Markdown 的思考》</a></strong></p>

<p>Markdown 即便在 2022 年也非常常用，比如这篇文章依然采用 Markdown 编写。 但 Markdown 是否应该成为文本编辑领域的默认技术选型呢？答案是否定的。我找到了一篇批判无脑使用 Markdown 作为技术选型的好文&nbsp;<strong><a href="http://link.zhihu.com/?target=https%3A//www.smashingmagazine.com/2022/02/thoughts-on-markdown/" target="_blank">Thoughts On  Markdown</a></strong>，它提到 Markdown 在标准化、结构…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/467098102" target="_blank">精读《vue-lit 源码》</a></strong></p>

<p><strong><a href="https://link.zhihu.com/?target=https%3A//github.com/yyx990803/vue-lit" target="_blank">vue-lit</a></strong>&nbsp;基于&nbsp;<strong><a href="https://link.zhihu.com/?target=https%3A//github.com/lit/lit/blob/main/packages/lit-html/README.md" target="_blank">lit-html</a></strong>&nbsp;+&nbsp;<strong><a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue-next/tree/master/packages/reactivity" target="_blank">@vue/reactivity</a></strong>&nbsp;仅用 70 行代码就给模版引擎实现了&nbsp;<strong><a href="https://link.zhihu.com/?target=https%3A//vuejs.org/guide/extras/composition-api-faq.html" target="_blank">Vue  Composition API</a></strong>，用来开发 web component。&nbsp;<strong>概述</strong>&nbsp;&lt;my-component&gt;&lt;/my-component&gt;  &lt;script type= …</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/464467147" target="_blank">精读《pipe operator for JavaScript》</a></strong></p>

<p><strong><a href="https://link.zhihu.com/?target=https%3A//github.com/tc39/proposal-pipeline-operator%23tacit-unary-function-application-syntax" target="_blank">Pipe  Operator (|&gt;) for JavaScript</a></strong>&nbsp;提案给 js 增加了 Pipe 语法，这次结合&nbsp;<strong><a href="https://link.zhihu.com/?target=https%3A//2ality.com/2022/01/pipe-operator.html" target="_blank">A pipe  operator for JavaScript: introduction and use cases</a></strong>&nbsp;文章一起深入了解这个提案。&nbsp;<strong>概述</strong>&nbsp;Pipe 语法可以将函数调用按顺序打平。如下方函数…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/461152248" target="_blank">精读《zustand 源码》</a></strong></p>

<p><strong><a href="http://link.zhihu.com/?target=https%3A//github.com/pmndrs/zustand" target="_blank">zustand</a></strong>&nbsp;是一个非常时髦的状态管理库，也是 2021 年 Star 增长最快的 React 状态管理库。它的理念非常函数式，API 设计的很优雅，值得学习。&nbsp;<strong>概述</strong>&nbsp;首先介绍&nbsp;<strong><a href="http://link.zhihu.com/?target=https%3A//github.com/pmndrs/zustand" target="_blank">zustand</a></strong>&nbsp;的使用方法。&nbsp;<strong>创建 store</strong>&nbsp;通过 create 函数创建  store，回调可拿到 get set 就类似 Redux 的 get…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/458275127" target="_blank">精读《2021 前端新秀回顾》</a></strong></p>

<p><strong><a href="http://link.zhihu.com/?target=https%3A//risingstars.js.org/2021/en" target="_blank">2021  JavaScript Rising Stars</a></strong>&nbsp;每年都会对前端开源项目进行点评，其依据是去年 Star 的增幅。Star  虽然只是一个维度，但至少反应了流行度，根据这个排行榜可以大体分析出前端社区的趋势。&nbsp;<strong>精读</strong>&nbsp;该榜单包含整体榜单、前端框架、Node 框架、构建工具、Vue 生态、React 生态、CSS-In-…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/455298252" target="_blank">精读《Excel JS API》</a></strong></p>

<p>Excel 现在可利用 js 根据单元格数据生成图表、表格，或通过 js 拓展自定义函数拓展内置 Excel 表达式。 我们来学习一下 Excel js API 开放是如何设计的，从中学习到一些开放 API 设计经验。 API 文档：<strong><a href="https://link.zhihu.com/?target=https%3A//docs.microsoft.com/en-us/office/dev/add-ins/reference/overview/excel-add-ins-reference-overview" target="_blank">Excel  JavaScript API overview</a></strong>&nbsp;<strong>精读</strong>&nbsp;Excel 将利用 JS A…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/452989809" target="_blank">精读《Records &amp; Tuples for React》</a></strong></p>

<p>继前一篇&nbsp;<strong><a href="http://link.zhihu.com/?target=https%3A//github.com/ascoders/weekly/blob/master/%25E5%2589%258D%25E6%25B2%25BF%25E6%258A%2580%25E6%259C%25AF/223.%25E7%25B2%25BE%25E8%25AF%25BB%25E3%2580%258ARecords%2520%2526%2520Tuples%2520%25E6%258F%2590%25E6%25A1%2588%25E3%2580%258B.md" target="_blank">精读《Records &amp; Tuples 提案》</a></strong>，已经有人在思考这个提案可以帮助 React 解决哪些问题了，比如这篇&nbsp;<strong><a href="http://link.zhihu.com/?target=https%3A//sebastienlorber.com/records-and-tuples-for-react" target="_blank">Records  &amp; Tuples for React</a></strong>，就提到了许多 React 痛点可以被解决。  其实我比较担忧浏览器是否能将 Records &amp; Tuples 性能优化…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/450188771" target="_blank">精读《Records &amp; Tuples 提案》</a></strong></p>

<p>immutablejs、immer 等库已经让 js 具备了 immutable 编程的可能性，但还存在一些无解的问题，即  “怎么保证一个对象真的不可变”。 如果不是拍胸脯担保，现在还真没别的办法。或许你觉得 frozen 是个 good idea，但它内部仍然可以增加非 frozen 的 key。 另一个问题是，当我们…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/447497181" target="_blank">精读《深入了解现代浏览器四》</a></strong></p>

<p><strong><a href="http://link.zhihu.com/?target=https%3A//developers.google.com/web/updates/2018/09/inside-browser-part4" target="_blank">Inside look  at modern web browser</a></strong>&nbsp;是介绍浏览器实现原理的系列文章，共 4 篇，本次精读介绍第四篇。&nbsp;<strong>概述</strong>&nbsp;前几章介绍了浏览器的基础进程、线程以及它们之间协同的关系，并重点说到了渲染进程是如何处理页面绘制的，那么最后一章也就深入到了浏览器是如何处理页面中事件的。  全篇站在浏览器实现的视角思考问…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/444558882" target="_blank">精读《深入了解现代浏览器三》</a></strong></p>

<p><strong><a href="http://link.zhihu.com/?target=https%3A//developers.google.com/web/updates/2018/09/inside-browser-part3" target="_blank">Inside look  at modern web browser</a></strong>&nbsp;是介绍浏览器实现原理的系列文章，共 4 篇，本次精读介绍第三篇。&nbsp;<strong>概述</strong>&nbsp;本篇宏观的介绍 renderer process 做了哪些事情。  浏览器 tab 内 html、css、javascript 内容基本上都由 renderer process 的主线程处…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/441706012" target="_blank">精读《深入了解现代浏览器二》</a></strong></p>

<p><strong><a href="http://link.zhihu.com/?target=https%3A//developers.google.com/web/updates/2018/09/inside-browser-part2" target="_blank">Inside look  at modern web browser</a></strong>&nbsp;是介绍浏览器实现原理的系列文章，共 4 篇，本次精读介绍第二篇。&nbsp;<strong>概述</strong>&nbsp;本篇重点介绍了&nbsp;<strong>浏览器路由跳转后发生了什么</strong>，下一篇会介绍浏览器的渲染进程是如何渲染网页的，环环相扣。  在上一篇介绍了，browser process 包含 UI thread、netwo…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/438879252" target="_blank">精读《深入了解现代浏览器一》</a></strong></p>
    <p align="left"><strong><a href="https://link.zhihu.com/?target=https%3A//developers.google.com/web/updates/2018/09/inside-browser-part1" target="_blank">Inside look  at modern web browser</a></strong>&nbsp;是介绍浏览器实现原理的系列文章，共 4 篇，本次精读介绍第一篇。 虽然本文写于 2018 年，但如今依然值得学习，因为浏览器实现非常复…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/436090437" target="_blank">精读《Rust 是 JS 基建的未来》</a></strong></p>

<p><strong><a href="http://link.zhihu.com/?target=https%3A//leerob.io/blog/rust" target="_blank">Rust Is The  Future of JavaScript Infrastructure</a></strong>&nbsp;这篇文章讲述了 Rust 正在  JS 基建圈流行的事实：<strong><a href="http://link.zhihu.com/?target=https%3A//github.com/webpack/webpack" target="_blank">Webpack</a></strong>、<strong><a href="http://link.zhihu.com/?target=https%3A//github.com/babel/babel" target="_blank">Babel</a></strong>、<strong><a href="http://link.zhihu.com/?target=https%3A//github.com/terser/terser" target="_blank">Terser</a></strong>、<strong><a href="http://link.zhihu.com/?target=https%3A//github.com/prettier/prettier" target="_blank">Prettier</a></strong>、<strong><a href="http://link.zhihu.com/?target=https%3A//github.com/eslint/eslint" target="_blank">ESLint</a></strong>&nbsp;这些前些年才流行起来的工具都已有了 Rust 替代方案，且性能有着 10～100 倍的提升。 前…</p>



<p><strong><a href="https://zhuanlan.zhihu.com/p/427957472" target="_blank">精读《什么是 LOD 表达式》</a></strong></p>
    <p align="left">LOD 表达式在数据分析领域很常用，其全称为  Level Of Detail，即详细级别。&nbsp;<strong>精读</strong>&nbsp;什么是详细级别，为什么需要 LOD？你一定会有这个问题，我们来一步步解答。&nbsp;<strong>什么是详细级别</strong>&nbsp;可以尝试这么发问：…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/425322116" target="_blank">精读《web streams》</a></strong></p>
    <p align="left">Node stream 比较难理解，也比较难用，但 “流” 是个很重要而且会越来越常见的概念（ fetch 返回值就是流），所以我们有必要认真学习 stream。 好在继 node stream 之后，又…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/422628213" target="_blank">精读《Prisma 的使用》</a></strong></p>
    <p align="left">ORM(Object  relational mappers) 的含义是，将数据模型与 Object 建立强力的映射关系，这样我们对数据的增删改查可以转换为操作  Object(对象)。 Prisma 是一…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/420022531" target="_blank">精读《可维护性思考》</a></strong></p>

<p>PS: 所有没给原文链接的精读都是原创，本篇也是原创。 前端精读之前写了 23 篇设计模式总结文，再加上 6 种设计原则，开闭、单一职责、依赖倒置、接口分离、迪米特法则、里氏替换原则，基本上对代码的可维护性有了全面深刻的理解。  但你我在工作中都会不断遇到烂代码，快要无法维护的大型项目，想一想，仅凭设计模式就能解决这些问题…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/414391532" target="_blank">精读《Microsoft Power Fx》</a></strong></p>
    <p align="left">Power Fx 是一门语言，虽然它被推荐的场景是低代码，但我们必须以一门语言角度看待它，才能更好的理解。 Power Fx 的创建是为了更好的辅助非专业开发人员，因此这门语言被设计的足够简单，希望这门…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/409706394" target="_blank">精读《class static block》</a></strong></p>
    <p align="left"><strong><a href="http://link.zhihu.com/?target=https%3A//github.com/tc39/proposal-class-static-block" target="_blank">class-static-block</a></strong>&nbsp;提案于&nbsp;<strong><a href="http://link.zhihu.com/?target=https%3A//github.com/tc39/proposal-class-static-block/commit/c0cabee0aa2d036a8d902fea7bc1d179e3de2477" target="_blank">2021.9.1</a></strong>&nbsp;进入 stage4，是一个基于 Class 增强的提案。 本周我们结合&nbsp;<strong><a href="http://link.zhihu.com/?target=https%3A//2ality.com/2021/09/class-static-block.html" target="_blank">ES2022  feature: class static init</a></strong>…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/407228656" target="_blank">精读《捕获所有异步 error》</a></strong></p>

<p>成熟的产品都有较高的稳定性要求，仅前端就要做大量监控、错误上报，后端更是如此，一个未考虑的异常可能导致数据错误、服务雪崩、内存溢出等等问题，轻则每天焦头烂额的处理异常，重则引发线上故障。  假设代码逻辑没有错误，那么剩下的就是异常错误了。 由于任何服务、代码都可能存在外部调用，只要外部调用存在不确定性，代码就可能出现异常，所…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/404917190" target="_blank">精读《Typescript 4.4》</a></strong></p>
    <p align="left">Typescript 4.4 正式发布了！距离 Typescript 4.5  发布还有三个月的时间，抓紧上车学习吧！ 本周精读的文章：<strong><a href="http://link.zhihu.com/?target=https%3A//devblogs.microsoft.com/typescript/announcing-typescript-4-4/" target="_blank">announcing-typescript-4-4</a></strong>&nbsp;<strong>概述</strong>&nbsp;<strong>更智能的自动类</strong>…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/402541135" target="_blank">精读《Typescript infer 关键字》</a></strong></p>
    <p align="left">Infer 关键字用于条件中的类型推导。  Typescript 官网也拿 ReturnType 这一经典例子说明它的作用： type ReturnType&lt;T&gt; = T extends (..…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/400159196" target="_blank">精读《一种 Hooks 数据流管理方案》</a></strong></p>
    <p align="left">维护大型项目 OR UI 组件模块时，一定会遇到全局数据传递问题。 维护项目时，像全局用户信息、全局项目配置、全局功能配置等等，都是跨模块复用的全局数据。  维护 UI 组件时，调用组件的入口只有一个，但组…</p>

<p><strong><a href="https://zhuanlan.zhihu.com/p/397800013" target="_blank">精读《JS with 语法》</a></strong></p>
    <p align="left">with 是一个不推荐使用的语法，因为它的作用是改变上下文，而上下文环境对开发者影响很大。  本周通过&nbsp;<strong><a href="http://link.zhihu.com/?target=https%3A//dev.to/mistval/javascript-s-forgotten-keyword-with-48id" target="_blank">JavaScript's  Forgotten Keyword (with)</a></strong>&nbsp;这篇文章介绍一下  wit…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/395367954" target="_blank">精读《默认、命名导出的区别》</a></strong></p>
    <p align="left">从代码可维护性角度出发，命名导出比默认导出更好，因为它减少了因引用产生重命名情况的发生。  但命名导出与默认导出的区别不止如此，在逻辑上也有很大差异，为了减少开发时在这方面栽跟头，有必要提前了解它们的区别…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/390965678" target="_blank">精读《算法 - 二叉搜索树》</a></strong></p>
    <p align="left">二叉搜索树的特性是，任何一个节点的值：  都大于左子树任意节点。 都小于右子树任意节点。 因为二叉搜索树的特性，我们可以更高效的应用算法。&nbsp;<strong>精读</strong>&nbsp;还记得&nbsp;<strong><a href="http://link.zhihu.com/?target=https%3A//github.com/ascoders/weekly/blob/master/%25E7%25AE%2597%25E6%25B3%2595/201.%25E7%25B2%25BE%25E8%25AF%25BB%25E3%2580%258A%25E7%25AE%2597%25E6%25B3%2595%2520-%2520%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%25E3%2580%258B.md" target="_blank">《算法 - 二叉树》</a></strong>&nbsp;提到的&nbsp;<strong><a href="http://link.zhihu.com/?target=https%3A//github.com/ascoders/weekly/blob/master/%25E7%25AE%2597%25E6%25B3%2595/201.%25E7%25B2%25BE%25E8%25AF%25BB%25E3%2580%258A%25E7%25AE%2597%25E6%25B3%2595%2520-%2520%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%25E3%2580%258B.md" target="_blank">二叉树的最近公公祖先</a></strong>&nbsp;问题吗…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/388891604" target="_blank">精读《React 18》</a></strong></p>
    <p align="left">React 18 带来了几个非常实用的新特性，同时也没有额外的升级成本，值得仔细看一看。 下面是几个关键信息：&nbsp;<strong><a href="http://link.zhihu.com/?target=https%3A//github.com/reactwg/react-18" target="_blank">React 18 工作小组</a></strong>。利用社区讨论 React 18 发布节奏与新特性。&nbsp;<strong><a href="http://link.zhihu.com/?target=https%3A//reactjs.org/blog/2021/06/08/the-plan-for-react-18.html" target="_blank">发布计划</a></strong>。目前…</p>



<p><strong><a href="https://zhuanlan.zhihu.com/p/386660927" target="_blank">精读《算法 - 二叉树》</a></strong></p>
    <p align="left">二叉树是一种数据结构，并且拥有种类复杂的分支，本文作为入门篇，只介绍一些基本二叉树的题型，像二叉搜索树等等不在此篇介绍。  二叉树其实是链表的升级版，即链表同时拥有两个 Next 指针，就变成了二叉树。 二…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/384626884" target="_blank">精读《算法 - 回溯》</a></strong></p>
    <p align="left">如何尝试走迷宫呢？遇到障碍物就从头 “回溯”  继续探索，这就是回溯算法的形象解释。 更抽象的，可以将回溯算法理解为深度遍历一颗树，每个叶子结点都是一种方案的终态，而对某条路线的判断可能在访问到叶子结点之…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/380707273" target="_blank">精读《算法 - 滑动窗口》</a></strong></p>
    <p align="left">滑动窗口算法是较为入门题目的算法，一般是一些有规律数组问题的最优解，也就是说，如果一个数组问题可以用动态规划解，但又可以使用滑动窗口解决，那么往往滑动窗口的效率更高。  双指针也并不局限在数组问题，像链表…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/378474581" target="_blank">精读《算法 - 动态规划》</a></strong></p>
    <p align="left">很多人觉得动态规划很难，甚至认为面试出动态规划题目是在为难候选人，这可能产生一个错误潜意识：认为动态规划不需要掌握。  其实动态规划非常有必要掌握： 非常锻炼思维。动态规划是非常锻炼脑力的题目，虽然有套路，…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/376614356" target="_blank">精读《低代码逻辑编排》</a></strong></p>
    <p align="left"><strong>知乎对 md 解析不好，推荐直接在&nbsp;<a href="https://link.zhihu.com/?target=https%3A//github.com/ascoders/weekly/blob/master/%25E5%2589%258D%25E6%25B2%25BF%25E6%258A%2580%25E6%259C%25AF/197.%25E7%25B2%25BE%25E8%25AF%25BB%25E3%2580%258A%25E4%25BD%258E%25E4%25BB%25A3%25E7%25A0%2581%25E9%2580%25BB%25E8%25BE%2591%25E7%25BC%2596%25E6%258E%2592%25E3%2580%258B.md" target="_blank">github 阅读</a>&nbsp;获得更好体验。</strong>&nbsp;逻辑编排是用可视化方式描述逻辑，在一般搭建场景中用于代替逻辑描述部分。 更进一步的逻辑编排是前后端逻辑混排，一般出现在一站式 paa…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/374718063" target="_blank">精读《前端职业规划 - 2021 年》</a></strong></p>
    <p align="left">不知道你上次思考前端职业规划是什么时候？  如果你是一位学生，你肯定对前端这个职业感到陌生，你虽然没有经验，但却对未来充满好奇，你有大把时间来思考，但可能摸不着方向，有种拳头打在棉花上的无力感。 如果你已经…</p>


<p><strong><a href="https://zhuanlan.zhihu.com/p/372857206" target="_blank">精读《新一代前端构建工具对比》</a></strong></p>
    <p align="left">本周精读的文章是&nbsp;<strong><a href="https://link.zhihu.com/?target=https%3A//css-tricks.com/comparing-the-new-generation-of-build-tools/" target="_blank">Comparing  the New Generation of Build Tools</a></strong>。 前端工程领域近期出了不少新工具，这些新工具都运用了一些新技术或者跨领域技术，实现了一些突破，因…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/371005457" target="_blank">精读《算法基础数据结构》</a></strong></p>
    <p align="left">掌握了不同数据结构的特点，可以让你在面对不同问题时，采用合适的数据结构处理，达到事半功倍的效果。  所以这次我们详细介绍各类数据结构的特点，希望你可以融会贯通。&nbsp;<strong>精读</strong>&nbsp;<strong>数组</strong>&nbsp;数组非常常用，它是一块连续的内存空间…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/367612332" target="_blank">精读《React Server Component》</a></strong></p>
    <p align="left">截止目前，React Server Component 还在开发与研究中，因此不适合投入生产环境使用。但其概念非常有趣，值得技术人学习。  目前除了国内各种博客、知乎解读外，最一手的学习资料有下面两处：&nbsp;<strong><a href="http://link.zhihu.com/?target=https%3A//reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html" target="_blank">D</a></strong>…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/365926725" target="_blank">精读《DOM diff 最长上升子序列》</a></strong></p>
    <p align="left">在&nbsp;<strong><a href="https://link.zhihu.com/?target=https%3A//github.com/ascoders/weekly/blob/v2/190.%25E7%25B2%25BE%25E8%25AF%25BB%25E3%2580%258ADOM%2520diff%2520%25E5%258E%259F%25E7%2590%2586%25E8%25AF%25A6%25E8%25A7%25A3%25E3%2580%258B.md" target="_blank">精读《DOM diff 原理》</a></strong>&nbsp;一文中，我们提到了 Vue 使用了一种贪心 + 二分的算法求出最长上升子序列，但并没有深究这个算法的原理，因此特别开辟一章详细说明。  另外，最长上升子序列作为一道算法…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/364094849" target="_blank">精读《高性能表格》</a></strong></p>
    <p align="left">每个前端都想做一个完美的表格，业界也在持续探索不同的思路，比如钉钉表格、语雀表格。  笔者所在数据中台团队也对表格有着极高的要求，尤其是自助分析表格，需要兼顾性能与交互功能，本文便是记录自助分析表格高性能…</p>


<p><strong><a href="https://zhuanlan.zhihu.com/p/362539108" target="_blank">精读《DOM diff 原理详解》</a></strong></p>
    <p align="left">DOM diff 作为工程问题，需要具有一定算法思维，因此经常出现在面试场景中，毕竟这是难得出现在工程领域的算法问题。  无论出于面试目的，还是深入学习目的，都有必要将这个问题搞懂，因此前端精读我们就专门…</p>



<p><strong><a href="https://zhuanlan.zhihu.com/p/360664179" target="_blank">精读《设计模式 - Visitor 访问者模式》</a></strong></p>
    <p align="left"><strong>Visitor</strong><strong>（访问者模式）</strong>&nbsp;Visitor（访问者模式）属于行为型模式。&nbsp;<strong>意图：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</strong>&nbsp;访问者，顾名思义…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/358858374" target="_blank">精读《设计模式 - Template Method 模版模式》</a></strong></p>
    <p align="left"><strong>Template Method</strong><strong>（模版模式）</strong>&nbsp;Template Method（模版模式）属于行为型模式。&nbsp;<strong>意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod 使得子类可</strong>…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/357163096" target="_blank">精读《设计模式 - Strategy 策略模式》</a></strong></p>
    <p align="left"><strong>Strategy</strong><strong>（策略模式）</strong>&nbsp;Strategy（策略模式）属于行为型模式。&nbsp;<strong>意图：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。本模式使得算法可以独立于使用它的客户而变化。</strong>&nbsp;策略是个形象的…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/355381153" target="_blank">精读《设计模式 - State 状态模式》</a></strong></p>
    <p align="left"><strong>State</strong><strong>（状态模式）</strong>&nbsp;State（状态模式）属于行为型模式。&nbsp;<strong>意图：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</strong>&nbsp;简单来说，就是将 “一个大 class + 一堆 if els…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/353646557" target="_blank">精读《设计模式 - Observer 观察者模式》</a></strong></p>
    <p align="left"><strong>Observer</strong><strong>（观察者模式）</strong>&nbsp;Observer（观察者模式）属于行为型模式。&nbsp;<strong>意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</strong>&nbsp;拿项目的 np…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/352002819" target="_blank">精读《设计模式 - Memoto 备忘录模式》</a></strong></p>
    <p align="left"><strong>Memento</strong><strong>（备忘录模式）</strong>&nbsp;Memento（备忘录模式）属于行为型模式，是针对如何捕获与恢复对象内部状态的设计模式。&nbsp;<strong>意图：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这</strong>…</p>

<p><strong><a href="https://zhuanlan.zhihu.com/p/348438972" target="_blank">精读《设计模式 - Mediator 中介者模式》</a></strong></p>
    <p align="left"><strong>Mediator</strong><strong>（中介者模式）</strong>&nbsp;Mediator（中介者模式）属于行为型模式。&nbsp;<strong>意图：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间</strong>…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/346788804" target="_blank">精读《设计模式 - Iterator 迭代器模式》</a></strong></p>
    <p align="left"><strong>Iterator</strong><strong>（迭代器模式）</strong>&nbsp;Iterator（迭代器模式）属于行为型模式。&nbsp;<strong>意图：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</strong>&nbsp;这种设计模式要解决的根本问题是，聚合的种…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/345061737" target="_blank">精读《设计模式 - Interpreter 解释器模式》</a></strong></p>
    <p align="left"><strong>Interpreter</strong><strong>（解释器模式）</strong>&nbsp;Interpreter（解释器模式）属于行为型模式。&nbsp;<strong>意图：给定一个语言，定义它的文法的一种表示，并定义一个解释器。这个解释器使用该表示来解释语言中的句子。</strong>&nbsp;任何一门语…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/343351271" target="_blank">精读《设计模式 - Command 命令模式》</a></strong></p>
    <p align="left"><strong>Command</strong><strong>（命令模式）</strong>&nbsp;Command（命令模式）属于行为型模式。&nbsp;<strong>意图：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</strong>&nbsp;<strong>举例子</strong>&nbsp;如果看…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/340016323" target="_blank">精读《设计模式 - Chain of Responsibility 职责链模式》</a></strong></p>
    <p align="left"><strong>Chain of  Responsibility</strong><strong>（职责链模式）</strong>&nbsp;Chain of Responsibility（职责链模式）属于行为型模式。行为型模式不仅描述对象或类的模式，还描述它们之间的通信模式，比如…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/338360356" target="_blank">精读《设计模式 - Proxy 代理模式》</a></strong></p>
    <p align="left"><strong>Proxy</strong><strong>（代理模式）</strong>&nbsp;Proxy（代理模式）属于结构型模式，通过访问代理对象代替访问原始对象，以获得一些设计上的便捷。&nbsp;<strong>意图：为其他对象提供一种代理以控制这个对象的访问。</strong>&nbsp;<strong>举例子</strong>&nbsp;如果看不懂上面的意图介绍，…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/336732854" target="_blank">精读《设计模式 - Flyweight 享元模式》</a></strong></p>
    <p align="left"><strong>Flyweight</strong><strong>（享元模式）</strong>&nbsp;Flyweight（享元模式）属于结构型模式，是一种共享对象的设计模式。&nbsp;<strong>意图：运用共享技术有效地支持大量细粒度的对象。</strong>&nbsp;<strong>举例子</strong>&nbsp;如果看不懂上面的意图介绍，没有关系，设计模式需…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/333225431" target="_blank">精读《设计模式 - Facade 外观模式》</a></strong></p>
    <p align="left"><strong>Facade</strong><strong>（外观模式）</strong>&nbsp;Facade（外观模式）属于结构型模式，是一种日常开发中经常被使用到的设计模式。&nbsp;<strong>意图：为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得</strong>…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/321613319" target="_blank">精读《设计模式 - Decorator 装饰器模式》</a></strong></p>
    <p align="left"><strong>Decorator</strong><strong>（装饰器模式）</strong>&nbsp;Decorator（装饰器模式）属于结构型模式，是一种拓展对象额外功能的设计模式，别名 wrapper 。&nbsp;<strong>意图：动态地给一个对象添加一些额外的职责。就增加功能来说，Dec</strong>…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/307385425" target="_blank">精读《设计模式 - Composite 组合模式》</a></strong></p>
    <p align="left"><strong>Composite</strong><strong>（组合模式）</strong>&nbsp;Composite（组合模式）属于结构型模式，是一种统一管理树形结构的抽象方式。&nbsp;<strong>意图：将对象组合成树形结构以表示 “部分 - 整体” 的层次结构。Composite 使得</strong>…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/296254090" target="_blank">精读《设计模式 - Bridge 桥接模式》</a></strong></p>
    <p align="left"><strong>Bridge</strong><strong>（桥接模式）</strong>&nbsp;Bridge（桥接模式）属于结构型模式，是一种解决继承后灵活拓展的方案。&nbsp;<strong>意图：将抽象部分与它的实现部分分离，使它们可以独立地变化。</strong>&nbsp;桥接模式比较难理解，我会一步步还原该设计模式的…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/280733597" target="_blank">精读《设计模式 - Adapter 适配器模式》</a></strong></p>
    <p align="left"><strong>Adapter</strong><strong>（适配器模式）</strong>&nbsp;Adapter（适配器模式）属于结构型模式，别名  wrapper ，结构性模式关注的是如何组合类与对象，以获得更大的结构，我们平常工作大部分时间都在与这种设计模式打交道。&nbsp;<strong>意图</strong>…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/271676432" target="_blank">精读《设计模式 - Singleton 单例模式》</a></strong></p>
    <p align="left"><strong>Singleton</strong><strong>（单例模式）</strong>&nbsp;Singleton（单例模式）属于创建型模式，提供一种对象获取方式，保证在一定范围内是唯一的。&nbsp;<strong>意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</strong>&nbsp;其实单例模式在前…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/268707945" target="_blank">精读《设计模式 - Prototype 原型模式》</a></strong></p>
    <p align="left"><strong>Prototype</strong><strong>（原型模式）</strong>&nbsp;Prototype（原型模式）属于创建型模式，既不是工厂也不是直接 New，而是以拷贝的方式创建对象。&nbsp;<strong>意图：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象</strong>…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/266694787" target="_blank">精读《设计模式 - Factory Method 工厂方法》</a></strong></p>
    <p align="left"><strong>Factory Method</strong><strong>（工厂方法）</strong>&nbsp;Factory Method（工厂方法）属于创建型模式，利用工厂方法创建对象实例而不是直接用 New 关键字实例化。 理解如何写出工厂方法很简单，但理解为什么要用…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/264989826" target="_blank">精读《设计模式 - Builder 生成器》</a></strong></p>
    <p align="left"><strong>Builder</strong><strong>（生成器）</strong>&nbsp;Builder（生成器）属于创建型模式，针对的是单个复杂对象的创建。&nbsp;<strong>意图：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</strong>&nbsp;<strong>举例子</strong>&nbsp;如果看不懂上面的意图介…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/256965682" target="_blank">精读《设计模式 - Abstract Factory 抽象工厂》</a></strong></p>
    <p align="left"><strong>Abstract Factory</strong><strong>（抽象工厂）</strong>&nbsp;Abstract Factory（抽象工厂）属于创建型模式，工厂类模式抽象程度从低到高分为：简单工厂模式 -&gt; 工厂模式 -&gt; 抽象工厂模式。&nbsp;<strong>意</strong>…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/25580812" target="_blank">谈谈 Redux 与 Mobx 思想的适用场景</a></strong></p>

<p>Redux 和 Mobx 都是当下比较火热的数据流模型，一个背靠函数式，似乎成为了开源界标配，一个基于面向对象，低调的前行。  函数式 vs 面向对象 首先任何避开业务场景的技术选型都是耍流氓，我先耍一下流氓，首先函数式的优势，比如： 无副作用，可时间回溯，适合并发。  数据流变换处理很拿手，比如 rxjs。 对于复杂数据逻辑、科学…</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/25245932" target="_blank">Javascript 异常处理的演进</a></strong></p>

<p>根据笔者的项目经验，本文讲解了从函数回调，到 es7 规范的异常处理方式。异常处理的优雅性随着规范的进步越来越高，不要害怕使用  try catch，不能回避异常处理。 我们需要一个健全的架构捕获所有同步、异步的异常。业务方不处理异常时，中断函数执行并启用默认处理，业务方也可以随时捕获异常自己处理。  优雅的异常处理方式就像冒…</p>    <p align="left"></p></div><div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>

<!--
_____________________________________________________________________________________

1 段落替换
\s*</p>

<p>\s*
------------------
</p>

<p>
_____________________________________________________________________________________
2 汉字中间的空格替换：
([\u4e00-\u9fa5])\s+([\u4e00-\u9fa5])
([^\s\*^{}"^u4e00-u9fa5])\s+([^\s\*^{}"^u4e00-u9fa5])------------------
$1$2
_____________________________________________________________________________________
3 段落前的空格替换
\s*</p>\s*
\s*<p>\s*
------------------
</p>

<p>
_____________________________________________________________________________________

4 把第和章两个字去掉
第(\S*)章
------------------
$1
_____________________________________________________________________________________

7 正则表达式参考：
https://www.toutiao.com/i6370960744082571778/
_____________________________________________________________________________________

8
<p class="picsay">
<p class="picsay">
<p class="code0">
<p class="code2">
<p class="code4">
_____________________________________________________________________________________
9 将标注序号更改为上标，红色，需一个个替换，英文html中有[1]
(\[\d\])
------------------
<sup>$1</sup>
_____________________________________________________________________________________
10 替换章不是以1-9。?！…”“结尾的段落
([^1-90。?！…”：？“章])</p>
<p>
------------------
$1
-->