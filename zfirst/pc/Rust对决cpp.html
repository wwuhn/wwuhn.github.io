<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:65.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h3{
	font-size:1.1em;
	font-weight:bold;
	text-indent:0em;
	color:#990000;
}
h4{
	font-size:1.0em;
	font-weight:bold;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	width:115%;
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	margin-left:2em;
	color:blue;
	overflow-x:auto;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style>
</head>

<body>

<div id="container">





<h3>Rust对决cpp</h3>

<p>
<p>Rust口碑那么好，为何学的人那么少？
<p>
<p>
<p><a href="https://www.toutiao.com/article/7125459765395816975">作者丨千山</a>
<p>
<p>
<p>
<p>放眼编程语言界，新旧势力的交替历来暗潮涌动又动人心弦。而在最近两年，Rust的表现不可谓不抢眼。
<p>
<p>根据SlashData 2021年开发者报告显示，使用Rust编程的开发人员在过去24个月内增长了两倍，达到了220万。过去C/C++、Java等是大厂的常用语言，而如今，字节跳动、亚马逊、谷歌、苹果均已经用上了Rust语言，这意味着学好Rust语言就有机会找到高薪工作。
<p>
<p>不过，也有人认为Rust学习门槛高，戏言“Rust的语法有点反人类”。那么事实到底如何呢？
<p>
<p><h3>PART 01 “当红炸子鸡”Rust 高效、安全但难学</h3>
<p>
<p>
<p>
<p>
<p>
<p>Rust最初由Mozilla员工Graydon Hoare在2006年设计和发布，目前由Mozilla团队和一众开源社区成员共同开发和维护。
<p>
<p>Rust能火，并非偶然。Graydon Hoare曾形容：“Rust是一种采用过去的知识解决将来的问题的技术。”站在前人的肩膀上，Rust很大程度上解决了很多其他编程语言的痛点。
<p>
<p>首先，Rust<strong>发挥了静态语言的优势</strong>。相较动态语言在调试和运行时的不确定性，静态类型的语言允许对数据及其行为预先进行编译器级别的检查和约束，在运行时只保留少量的类型检查，这极大地避免了程序员的麻烦，同时有益于鼓励长期的可维护性。
<p>
<p>其次，Rust<strong>解决了并发条件下的数据竞争问题</strong><strong>，让并发更容易</strong>。当两个线程同时访问同一内存时会发生数据竞争，这就可能导致某些不可预测的行为。Rust从编译阶段就将数据竞争解决在了萌芽状态，保障了线程安全。用户可以用库的形式实现各种高效且安全的并发编程模型，进而充分利用多核时代的硬件性能。
<p>
<p>再者，Rust<strong>做到了更好的内存安全特性</strong>。在内存管理上，常见的方式有两种：要么如Java、Python一样使用垃圾回收算法，要么像C++一样手工管理内存。但垃圾自动回收必然影响性能，手工管理内存则可能会出现内存泄漏和悬停指针之类的问题。Rust不同，其所有权系统在编译时就分析程序的内存管理，而且没有额外的运行时开销。这种无垃圾回收器的内存安全机制是Rust经典且核心的设计之一。
<p>
<p>还有，作为系统级编程语言，Rust的基本理念是 “<strong>零成本抽象</strong>”。这一理念让Rust<strong>具备高级语言表达能力的同时，又不会带来性能损耗</strong>。与其他系统级编程语言（如C或C ++）相比，Rust不需要程序员将所有时间都花在细节上，而是通过添加更高层次的编程概念，确保使用的抽象几乎没有运行时开销，这种抽象与等效的手写代码具有同等的性能。
<p>
<p>总的来说，在性能上，Rust内存利用率极高，能够胜任对性能要求特别高的服务；在安全性上，Rust丰富的类型系统和所有权模型保证了内存安全和线程安全，在编译期就能够有效阻断各种错误的产生。
<p>
<p>有着如此表现的Rust虽然还是编程语言界的“小鲜肉”，却迅速收获了开发者们的青睐。根据Stack Overflow 2021年开发者调查报告，Rust连续六年成为最受开发者喜爱的编程语言。
<p>
<p>不过，“最受喜爱”并不等于“最想使用”。
<p>
<p>尽管口碑好、人气高，但Rust的学习成本高几乎是众所周知的。在官方的多次调查中，不少开发者提到需要降低学习门槛，让Rust更容易被学习。2021年Rust Survey调查中，有47.41%的受访者认为采用Rust很有挑战性，仅有17.14%认为挑战性不大。
<p>
<p>
<p>
<p>
<p>可以说，除了部分具备一定的C/C++经验的开发者在使用Rust时会容易一点，很多人会因为“太难上手”而对Rust望而生畏。
<p>
<p><h3>PART 02 Rust对决C++ 以卵击石还是后生可畏</h3>
<p>
<p>
<p>
<p>
<p>
<p>Rust到底值不值得花功夫去上手？我们可以从它与其他语言的比较中一窥端倪。
<p>
<p>Rust常常被认为是C++的竞争语言，但这种说法也会被一些C++拥护者吐槽为“碰瓷”。不可否认，Rust很受欢迎，且颇有后劲，但目前来说，C++的主导地位依旧不可动摇。宏观来看，C++拥有更大的社区、更广泛的用例，并且在实战中得到了绝大多数企业的认可。但另一方面，Rust在安全性上表现更优，没有C++那么重的历史包袱，作为新生力量潜力更大，等生态更加丰富后可能会更有作为。
<p>
<p><strong>内存安全</strong>：同为系统级编程语言，C++为了保持速度，没有走内置垃圾回收机制的路子，将内存安全问题留给了开发人员。而Rust通过其所有权系统全面强制并提高了其内存安全性，基本消除了手动内存管理的需要。
<p><strong>智能指针</strong>：Rust和C++语言都广泛支持指针，在两种语言中，首选都是智能指针。Rust标准库提供了几种与C++类似的智能指针，如Box<T>相当于C++中的std::unique_ptr<T>;Rc<T>相当于C++中的std::shared_ptr<T>。
<p><strong>框架和库</strong>：Rust和C++都有大量的框架和库可以使用。尽管发展时长差距较大，但Rust目前已经有大量库可供网页开发、游戏开发、区块链等使用。而 C++库主要是标准库，是类和函数的集合。两种语言都有大量活跃的贡献者。
<p><strong>包管理和工具</strong>：Rust的官方包管理器是Cargo，就普遍反馈来说比较好用、很有竞争力。而C++在包管理方面也有Conan之类的工具，发展也不错。两者使用体验如何见仁见智。
<p><strong>并发性</strong>：两种语言在并发中表现均很稳健。但在线程安全方面，面对数据竞争这种难以定位的并发漏洞类型，Rust的内存安全特性更有助于预防这类问题的发生。不过，对自身代码非常自信的程序员可能会觉得，Rust在实现多线程应用时过于束缚。
<p><strong>社区支持</strong>：C++有C++标准委员会的领导，而Rust也有Rust基金会的支持。两种语言的社区都很活跃。不过因为C++发展时间要长得多，生态上肯定要比Rust成熟很多，受众基础也要大得多。
<p>归根结底，所有语言都是工具，真正使用时都要因地制宜。作为一门优缺点都极为鲜明的语言，Rust在实战中表现如何仍需要开发者的亲手验证。有位C++程序员的评价或许可以给我们更多启发：
<p>
<p>“虽然Rust定位于一门系统级编程语言，但它并<strong>没走C++兼容C的老路，完全没有历史的包袱，可以轻装上阵</strong>，充分吸收各家编程语言之长，避其之短。Rust有完全不亚于C++的表达能力和性能，又解决了<strong>C++的最大痛点（内存安全、线程安全）</strong>，这对C++程序员来讲无疑是非常有吸引力的。目前，C++仍然是我的主力编程语言，但我对Rust是看好的。它不仅实用，反过来也会促进对C++中关键概念和问题的理解。”
<p>
<p><h3>PART 03 前景：Rust会登顶吗？</h3>
<p>
<p>
<p>
<p>在代码江湖，编程语言总是呈现出“江山代有才人出”的态势。Rust作为一门年轻的语言，面向一众老前辈，也展示出了作为后起之秀的锐气和野心。
<p>
<p>在今年上半年， Rust语言设计团队（Lang Team）在官方博客中公布了Rust语言2024年的更新路线图。这张路线图昭示了Rust语言的未来发展方向。其重点有三：
<p>
<p>一是努力<strong>拉平陡峭的学习曲线</strong>。面向Rust学习门槛高的问题，Lang Team力图通过各种手段简化程序，使开发者能更轻松地表达代码意图，而不需要处理逻辑实现的各种细枝末节。
<p>
<p>二是<strong>让Rust库的生态系统更加轻松协调</strong>。Lang Team希望通过帮助管理功能生命周期，扩展库的功能，以及增强互操作性，使库的作者能够更好地服务于他们的用户。
<p>
<p>三是进一步<strong>扩大Rust项目规模</strong>。为更有效地推进Rust发展，Lang Team希望让开发者能对团队的现存问题、工作状况一目了然，并对他们可以如何提供帮助更加清晰，使开发人员能够积极参与推动他们热衷的工作。
<p>
<p>不过，对于Rust的前景，依旧众说纷纭。
<p>
<p>有人说，Rust可能还是干不过老语言，终究难逃昙花一现的命运；
<p>
<p>也有人说，Rust可能在Web应用开发、嵌入式设备开发等领域另辟洞天、大有作为；
<p>
<p>还有人说，Rust也许会吞下C++大部分应用场景，在漫长的发展期后完成登顶……
<p>
<p>而对于程序员是否要学Rust，支持和反对阵营也同样各执己见。
<p>
<p>支持者给出的理由，主要集中在以下几点：
<p>
<p>Rust站在巨人的肩膀上，也确实解决了C++的部分问题，很好地平衡了性能和开发效率。
<p>一些企业，尤其是大型公司，已经在使用Rust或正计划使用Rust。以后对于Rust开发者的需求会持续上升，而且可以预见薪酬很可观。
<p>作为一门年轻的语言，Rust的领域还没那么卷。抓住这个时机就有望成为这片“新大陆”的掘金者。
<p>反对者则认为：
<p>
<p>从职业发展考虑，对萌新来说，学习Rust得不偿失。因为Rust目前还是一门小众语言，将来会发展成什么样均未可知。而其他更为成熟的语言，掌握之后在实践中已经可以满足大部分业务需求。
<p>Rust的学习门槛决定了，有能力钻研其语法的程序员，用别的语言也很少会犯Rust想要从根源上杜绝的"低级错误"；而对于基础薄弱、编程思维混乱的程序员，很少能学进去Rust。这个矛盾就让Rust有点“不上不下”。
<p>程序真正面向的是人，而不是机器。语法简单、易于理解、减少程序员的心智负担才应该是编程语言未来的发展方向。Rust显然不符合这一点。
<p>回顾这些论点，可以发现，其实作为局中人，要预判一门语言的发展是很难的，因为没有人可以窥见其发展全貌。而且每门语言的发展也需遵循其自身的生命周期，不同阶段的评判标准不同，结论自然也不一样。或许就像有人说的，“我不讨厌任何编程语言，我只是讨厌还没掌握的语言。”具体到每一个开发者，所有的争论、质疑、好恶都要在尝试、学习、实操中逐步地变化演进。
<p>
<p>
<p>
<p>参考资料：
<p>
<p>https://zhuanlan.zhihu.com/p/342849423 <p>
<p>https://blog.csdn.net/oSuiYing12/article/details/106844271 <p>
<p>https://www.toutiao.com/article/7083687609608339998/
<p>
<p>https://lang-team.rust-lang.org/roadmaps/roadmap-2024.html
<p>
<p>https://thestack.technology/rust-language-explosive-growth-challenges-rust-governance/
<p>
<p>来源：51CTO技术栈


<p style='float:right;'>本页共115段，4620个字符，11071 Byte(字节)</p>﻿
<h3>谷歌推出Carbon，C++的实验替代品 Carbon</h3>
<p>Google Launches Carbon, an Experimental Replacement for C++</p>
<p>谷歌推出Carbon，C++的实验替代品Carbon</p>
<p>Frustrated by the slow evolution of the C++, Google engineers have launched a new “experimental” open source programming language, called Carbon, as a possible successor to the venerable but aging C++.</p>
<p>由于对C++的缓慢发展感到失望，谷歌工程师推出了一种新的“实验性”开源编程语言，称为Carbon，作为古老但老化的C++的可能继任者。</p>
<p>Just as Microsoft built Typescript to update JavaScript, and Kotlin was created to shore up weaknesses in Java, Carbon could serve as a successor language to C++, one that offers an easy jumping off point for developers to a newer language that addresses modern development concepts such as memory safety and generics.</p>
<p>正如微软构建Typescript来更新JavaScript，创建Kotlin是为了弥补Java的不足，Carbon可以作为C++的后续语言，为开发人员提供一个轻松的起点，以开发一种新的语言，解决内存安全和泛型等现代开发概念。</p>
<p>Google engineer Chandler Carruth introduced the language this week at the CPP North C++ conference in Toronto.</p>
<p>谷歌工程师钱德勒·卡拉斯本周在多伦多举行的CPP North C++会议上介绍了该语言。</p>
<p>Wither C++</p>
<p>凋零的C++</p>
<p>Long the language of choice for building performance-critical applications, C++ is plagued with a number of issues that hamper modern developers, Carruth explained on a GitHub page.  It has accumulated decades of technical debt, bringing with it many of the outdated practices that were part of the language’s predecessor, C. The keepers of C++ prioritize backward compatibility, in order to continue to support widely-used projects such as Linux and its package management ecosystem, Carruth charged.</p>
<p>Carruth在GitHub的一个页面上解释说，C++长期以来一直是构建性能关键型应用程序的首选语言，但它面临着许多阻碍现代开发人员的问题。它积累了数十年的技术债务，带来了许多过时的做法，这些做法是该语言的前身C的一部分。Carruth指出，C++的守护者优先考虑向后兼容性，以便继续支持广泛使用的项目，如Linux及其包管理生态系统。</p>
<p>The language’s evolution is also stymied by a bureaucratic committee process, oriented around standardization rather than design. Which can make it difficult to add new features.  C++ has largely a sequestered development process, in which a select committee makes the important decisions, in a waterfall process that can take years.</p>
<p>该语言的演变也受到官僚委员会流程的阻碍，该流程以标准化而非设计为导向。这会使添加新功能变得困难。C++在很大程度上是一个封闭的开发过程，在这个过程中，一个专门委员会会做出重要的决定，这是一个瀑布式的过程，可能需要几年的时间。</p>
<p>“The committee structure is designed to ensure representation of nations and companies, rather than building an inclusive and welcoming team and community of experts and people actively contributing to the language,” Carruth wrote. “Access to the committee and standard is restricted and expensive, attendance is necessary to have a voice, and decisions are made by live votes of those present.”</p>
<p>“委员会的结构是为了确保国家和公司的代表性，而不是建立一个包容和欢迎的团队和专家社区，以及积极为该语言做出贡献的人，”Carruth写道。“进入委员会和标准委员会的机会受到限制，费用昂贵，出席会议必须有发言权，决定由出席者现场投票作出。”</p>
<p>Carruth wants to build Carbon by a more open community-led environment. The project will be maintained on GitHub, and discussed on Discord.</p>
<p>卡鲁斯希望通过一个更开放的社区主导的环境来建设Carbon排放。该项目将在GitHub上维护，并在Discord上讨论。</p>
<p>While Carbon began as a Google internal project, the development team ultimately wants to reduce contributions from Google, or any other single company, to less than 50% by the end of the year. They ultimately want to  hand the project off to an independent software foundation, where its development will be led by volunteers.</p>
<p>虽然Carbon最初是谷歌内部项目，但开发团队最终希望在今年年底之前将谷歌或任何其他单一公司的贡献减少到50%以下。他们最终希望将该项目移交给一个独立的软件基金会，由志愿者领导其开发。</p>
<p>What’s in the Box?</p>
<p>盒子里有什么？</p>
<p>The design wants to release a core working version (“0.1”) by the end of the year. Carbon will be built on a foundation on modern programming principles, including a generics system, that would remove the need to check and recheck the code for each instantiation.</p>
<p>该设计希望在年底前发布一个核心工作版本（“0.1”）。Carbon将建立在现代编程原则的基础上，包括泛型系统，这将消除对每个实例化的代码进行检查和重新检查的需要。</p>
<p>Another much needed feature lacking in C++ is memory safety. Memory access bugs are one of the largest culprits of security exploits. Carbon designers will look for ways to better track uninitialized states, design APIs and idioms that support dynamic bounds checks, and build a comprehensive default debug build mode. Over time, the designers plan to build a safe Carbon subset.</p>
<p>C++中另一个急需的功能是内存安全。内存访问错误是安全漏洞攻击的最大元凶之一。Carbon设计者将寻找更好地跟踪未初始化状态的方法，设计支持动态边界检查的API和习惯用法，并构建全面的默认调试构建模式。随着时间的推移，设计师们计划建造一个安全的Carbon子集。</p>
<p>According to the documentation, the language will support:</p>
<p>根据文件，该语言将支持：</p>
<p>Performance-critical software</p>
<p>性能关键型软件</p>
<p>Software and language evolution</p>
<p>软件和语言进化</p>
<p>Code that is easy to read, understand, and write</p>
<p>易于阅读、理解和编写的代码</p>
<p>Practical safety and testing mechanisms</p>
<p>实用安全和测试机制</p>
<p>Fast and scalable development</p>
<p>快速且可扩展的开发</p>
<p>Modern OS platforms, hardware architectures, and environments</p>
<p>现代操作系统平台、硬件架构和环境</p>
<p>Interoperability with and migration from existing C++ code.</p>
<p>与现有C++代码的互操作性和迁移。</p>
<p>The development team will also set out to create a built-in package manager, something that C++ sorely lacks.</p>
<p>开发团队还将着手创建一个内置的包管理器，这是C++非常缺乏的。</p>
<p>Here is some C++ code translated into Carbon. First, the C++ code:</p>
<p>这里是一些C++代码翻译成Carbon。首先，C++代码：</p>
<p><p><a href="https://cdn.thenewstack.io/media/50657eb5-cpp_snippet.svg" class="local-link"><img loading="lazy" class="aligncenter wp-image-22678593 size-large" src="https://cdn.thenewstack.io/media/./50657eb5-cpp_snippet.svg" alt="" width="640" height="640" /></a></p></p>
<p>Here is the same function written in Carbon:</p>
<p>下面是用Carbon写的相同函数：</p>
<p><p><a href="https://cdn.thenewstack.io/media/30e03f42-carbon_snippet.svg" class="local-link"><img loading="lazy" class="aligncenter wp-image-22678594 size-large" src="https://cdn.thenewstack.io/media/./30e03f42-carbon_snippet.svg" alt="" width="640" height="640" /></a></p></p>
<p>The development team plans to write translation tools to migrate C++ code into Carbon code.</p>
<p>开发团队计划编写翻译工具，将C++代码迁移到Carbon代码中。</p>
<p>Why Not Rust Then?</p>
<p>那为什么不是Rust呢？</p>
<p>Rust was another recent language built specifically to address the needs of memory-safe performance applications. So why not just use Rust then? In his presentation at CPP North, Carruth advised those using Rust to continue to use it. Carbon is for those developers who already have large codebases in C++, which are difficult to convert into Rust. Carbon is specifically what Carruth called a “successor language,” which is built atop of an already existing ecosystem, C++ in this case.</p>
<p>Rust是另一种最近开发的语言，专门用于满足内存安全性能应用程序的需求。那么为什么不直接用Rust呢？在CPP North的演讲中，Carruth建议那些使用Rust的人继续使用Rust。Carbon是为那些已经在C++中拥有大量代码基的开发人员设计的，这些代码基很难转化为Rust。Carbon就是Carruth所说的“后继语言”，它建立在已经存在的生态系统之上，在本例中是C++。</p>
<p>“It is designed around interoperability with C++ as well as large-scale adoption and migration for existing C++ codebases and developers,” the documentation explains. This means the language should be as performant as C++, it should provide seamlessly, and offer bidirectional interoperability with C++.</p>
<p>“它是围绕与C++的互操作性以及现有C++代码库和开发人员的大规模采用和迁移而设计的，”文档解释道。这意味着该语言的性能应该与C++一样，它应该无缝地提供，并提供与C++的双向互操作性。</p>
<p>Google’s #Carbon programming language reminds me of the approach Apple took going from #ObjC to #Swift. In my experience that was a really good approach. It made porting Objective-C code to Swift a lot easier, since you never had to do a full port.https://t.co/dQK5wV0J0B</p>
<p>谷歌的Carbon编程语言让我想起了苹果从ObjC到Swift的方法。根据我的经验，这是一个非常好的方法。这使得将Objective-C代码移植到Swift变得更加容易，因为您永远不必进行完整的移植。https://t.co/dQK5wV0J0B</p>
<p>— Erik Engheim (@erikengheim) July 20, 2022</p>
<p>-埃里克·恩海姆（@erikengheim）2022年7月20日</p>

<p><h3>Google终于开始革C++的命了</h3></p>


<p>微软想通过TypeScript 革了JavaScript的命</p>
<p>苹果想用Swift革了Objective-C的命</p>
<p>JetBrains 想用Kotlin 革了Java的命</p>
<p>现在，Google终于要拿C++开刀了。</p>
<p>这个黑色圆圈中的C可不是C语言，而是叫做：</p>
<p>Carbon</p>
<p>为啥Google要搞一个Carbon呢？C++不是Google的五大语言之一吗？</p>
<p>C++，Java，Python，JavaScript，Go</p>
<p>长期以来，C++是构建性能关键型应用程序员的主要语言，也积累了大量的项目和类库。</p>
<p>但是C++本身非常复杂，数十年下来，这些项目和类库慢慢变成了技术债务。</p>
<p>C++虽然也在努力发展，但是受到了官僚委员会流程的阻碍，这个流程以标准化而不是设计为导向，添加新功能很困难，一个特别委员会可能需要数年的瀑布流程才能做出重要决定。</p>
<p>可以想象，当Google的人面对着海量C++代码的系统，想改进C++又很难的时候，那种无奈的心情。</p>
<p>既然如此，那就重启炉灶，用碳(Carbon)去燃烧C++吧！</p>
<p>为什么不直接用Rust?</p>
<p>可能很多人有这个疑问，Rust也面向系统级编程，并且被Mozilla设计成内存安全的语言，用来替代C语言。</p>
<p>Google认为，对于新项目来说，用Rust很合适，但是问题在于：</p>
<p>它不像 Java 和 Kotlin 那样具有“双向互操作性”，C++的生态迁移到Rust是很困难的。</p>
<p>而Carbon的目标是C++的后继，是围绕与C++的互操作性以及迁移现有C++代码库而设计的。</p>
<p>不得不说，生态的威力再一次展现，当你想让别人搬家的时候，最好能把他手头的财产一并都搬走，否则每个人都会恋恋不舍。</p>
<p>Carbon的设计目标是这样的：</p>
<p>性能要和C++相媲美，要不然就没有吸引力了</p>
<p>和C++无缝的，双向的互操作</p>
<p>代码应该容易编写、阅读</p>
<p>有着实用的安全和测试机制</p>
<p>要有一个温和的学习曲线，别把人都吓跑了</p>
<p>支持现有的软件设计和架构</p>
<p>开发团队还将着手创建一个内置的包管理器，这几乎是每个语言必备的工具了。</p>
<p>这样，Carbon就可以像TypeScript和Kotlin那样，基于现有C++的生态系统，吸引开发人员，保护现有投资。</p>
<p>看下Carbon的代码吧：</p>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
import Console;
<font color=#CCC>// Prints the Fibonacci numbers less than `limit`.</font>
fn Fibonacci(limit: i64) {
    var (a: i64, b: i64) = (0, 1);
   <font color=#00F> while</font>(a &lt; limit) {
        Console.Print(a, " ");
        let next: i64 = a + b;
        a = b;
        b = next;
    }
    Console.Print("\n");
}
</pre>

<p>用fn来定义函数，用var 来声明变量，变量类型后置，有Go语言的影子。</p>
<p>用大括号定义函数体和代码块，用分号来分割语句，while 关键字， 有C语言的感觉。</p>
<p>Console.Print(...)，有点C#的味道。</p>
<p>总之，虽然号称是C++的后继，但一点儿也不像C++。</p>
<p>语言特性</p>
<p>我浏览了一下，感兴趣的特性有这些：</p>
<p>指针</p>
<p>指针号称是C语言和C++的精华，可以直接操作内存，强大又灵活。</p>
<p>不过指针也是万恶之源，把指针指向不该指向的地方，程序马上崩溃。</p>
<p>Carbon中也有指针：T* p , 但是为了安全，并不支持指针的算术运算如 p++</p>
<p>Carbon中没有空指针，要指向一个无效的对象，需要使用Optional(T*)</p>
<p>既然有指针，还要和C++互操作，那垃圾收集之类的技术肯定是没法用了，自己小心地管理内存吧。</p>
<p>只提供一种方法来做事情</p>
<p>对于一件事情，Perl语言提供了很多方式来做，在非常灵活的同时也让代码维护者非常困扰。</p>
<p>C++也是这样，例如可以用 "&&" 或者 "and"来表示逻辑运算，可以用struct 和class 来封装数据。可以用0xaa和0xAA表示十六进制。</p>
<p>为了提高代码的可读性和可维护性，促进团队协作，Carbon决定向Python学习：应该只有一种最好的，最明显的方式来做事情。</p>
<p>安全</p>
<p>Carbon 对软件的考量是这样的：</p>
<p>内存安全：不允许越界访问，取消null指针，取消未初始化的指针，禁止访问已经释放的地址</p>
<p>类型安全：不允许用不正确的类型来访问有效的内存</p>
<p>数据竞争安全：防止多个线程在没有“同步”的情况下对内存地址进行读写</p>
<p>其他的特性例如泛型、类.....我这里就不一一赘述了，感兴趣的可以到GitHub上去看看：</p>
<p>https://github.com/carbon-language/carbon-lang</p>
<p>开发方式</p>
<p>Carbon 是Google内部发起的，但是Carbon团队认为为了未来取得成功，未来需要独立的、开放的社区来主导。</p>
<p>不能像C++委员会那样，虽然保证了国家和公司的代表性，但是限制太多，成本高昂，不出席会议就没有发言权，只有现场人员的投票才能决定。</p>
<p>这和现在的主流开源方式大相径庭，所以Carbon不走“ISO流程”，要拥抱开源，将来由软件基金会和志愿者领导。</p>


</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>
