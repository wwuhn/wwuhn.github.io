<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>摘录PCnotes</title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//谷歌浏览器
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop属
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//谷歌浏览器
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox等浏览器
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//谷歌浏览器
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox等浏览器  
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000">红色</option><option value="#006600">绿色</option><option value="#0000ff">蓝色</option><option value="#660000">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:75.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:100%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style></head><body onload="downn();">
<div>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	//if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	//}
</script>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a><a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a></div>
<div id="container">
<script>
	goTopEx();
</script><p>在十字链表中，矩阵的每一个非零元素用一个结点表示，该结点除了（row,col,value）以外，还添加以下两个链域：right用于链接同一行的下一个非零元素，down用于链接同一列中的下一个非零元素。在十字链表中，同一行的非零元素通过right域连接成一个单链表，同一列的非零通过down域链接成一个单链表；</p>
<p>由于广义表的数据元素可以是单个元素，也可以是子表，因此对于广义表来说，难以用顺序存储结构来表示它，通常用链式存储结构来表示。</p>

<p>在内存中组织各种数据结构，可采用顺序存储或链式存储。对数量特别大的数据元素集合，一般需要存放于外存中。因此，有索引存储和散列存储。索引存储通过建立索引表来组织所有数据元素，散列存储通过散列函数直接把数据记录的关键码映射为该元素的存放地址。</p>
<p>对于线性表（顺序表和单链表）的遍历，注意指针移动的细微区别。在顺序表中，申请一个指针p后，p指示数据元素的存储位置，用*p可取得该数据的值，用p++可以顺序进到物理上下一个元素的位置。在单链表的情形下，指针p指示链表的结点地址，用*p不能取得该结点数据的值，用p++也不能进到下一个结点位置，只能使用p->data取得结点数据的值，用p=p->next进到下一个结点。</p>
<p>完全二叉树的最典型应用就是——堆。</p>
<p>图（Graph）是由顶点（图中的结点称为图的顶点）的非空有限集合V（由N>0个顶点组成）与边的集合E（顶点之间的关系）所构成的。</p>
<p>图生成树：若图G为包含n个顶点的连通图，则G中包含其全部n个顶点的一个极小连通图，称为G的生成树。G的生成树一定包含且仅包含G的n-1条边。</p>
<p>数据结构中数据元素的操作：初始化、求长度、取元素、定位、插入、删除、遍历、查找；这就是数据结构的算法</p>
<p>堆通常是一个可以被看做一棵树（完全二叉树）的数组对象。</p>

<p>为了避免数组插入和删除和线性开销，我们需要允许序列数组可以不连接存储，否则序列数组的部分或全部需要整体移动，这就是链表。</p>

<p>对于大量的输入数据，链表的线性访问时间太慢，不宜使用，可以解决这个问题的是二叉查找树。</p>

<p>查找树的问题在于，其性能严重地依赖于输入，而输入则是随机的。</p>

<p>二叉堆，也就是二叉树，是一种根节点小于叶节点的二叉树，可以实例优先队列；</p>

<p>如果是左节点都小于右节点，则是一棵排序二叉树；</p>
<p>数据结构是指数据元素间的逻辑关系，即数据的逻辑结构。它可以看作是从具体问题抽象出来的数据模型，与数据的存储无关。</p>

<p>数据的存储结构是数据逻辑结构在计算机内的表示，它依赖于数据的逻辑结构。</p>

<p>作用于数据结构上的操作的实现依赖于相应的存储结构。</p>

<p>数据的逻辑结构分为线性、树形结构、图结构、集合结构。线性结构中元素之间的关系是一对一的，集合结构中元素之间的关系为空，树结构中元素之间的关系是一对多的，图结构中元素的关系是多对多的。</p>

<p>数据的存储结构为分四类，分别是顺序存储、链式存储、索引存储、散列存储；</p>

<p>在内存中组织各种数据结构，可采用顺序存储和链式存储。前者采用连续的存储区域相继存放数据元素，后者采用链表存储数据元素并通过各个元素附加的指针将它们的逻辑顺序连接起来。</p>

<p>对于数量特别大的数据元素集合，一般需要存入在外存中。因此，有索引存储和散列存储。前者通过建立索引表来组织所有数据元素，后者通过散列函数直接把数据记录的关键码映射为该元素的存放地址。</p>

<p>基本数据类型：数据的取值范围及其上的一组操作，通过操作符体现；</p>

<p>数据结构：数据元素的逻辑关系及存储实现，以及施加于数据结构之上的操作，相当于一个运算的集合，例如查找、插入、删除、更新、排序等，这些操作可以定义为函数来实现。如果将数据结构定义为类，则这些操作可以通过类方法来实现。</p>

<p>线性结构不管是顺序存储还是链式存储，前后元素之间都是一对一的关系。而非线性结构的树结构和图结构就不一样了。需要存储两方面的数据，一是元素集合，一个是元素关系的集合。如图形结构就可以用一个二维数据来存储元素的关系。树形结构可以看作是一个特殊的图。</p>

<p>图中元素的关系也可以用链表来实现，如邻接表、十字链表；</p>

<p>线性存储元素时，元素的关系也同时确定了。而非线性数据结构就不同了，需要同时考虑存储数据元素和数据元素的关系。如图的矩阵存储就是用一个顶点向量存储顶点元素，再用一个邻接矩阵存储元素关系。</p>

<p>图的边集存储：顶点数据+边集数组；</p>

<p>图的邻接存储：顶点表+n个链表（顶点元素及链接到相邻顶点的指针、下一个相邻点及指针……）；</p>

<p>有向图存储全部信息同时还需要一个逆邻接表；</p>

<p>带权图的邻接表则需要结点元素多一个权值域；</p>

<p>邻接表：一个顶点表，顶点表的元素是一个链接表；</p>
<p>数据结构，把数据的关系也抽象为数据。</p>

<p>关系可以是存储关系（链表的指针或引用，节点用结构体或类定义）及逻辑关系（图的边）。</p>

<p>数据类型就必须是复合数据类型（或叫结构数据类型）。</p>

<p>如果数据项连续存储，而关键码就是存储数据的地址（或下标）。</p>

<p>单链表的存储结构</p>
<pre>
typedef int DataType;
typedef struct node{
    DataType data;
    struct node *link;
}LinkedNode, *LinkList;
LinkedNode *hpt
LinkList hpt2
</pre>
<p>树的双亲结点表示法</p>
<pre>
#define MAXSIZE 60
Typedef char DataType;
Typedef struct node{
    DataType data;
    int parent;  结点双亲
} PTNode;
Typedef struct{
PTNode tnode[MAXSIZE];
int n;  //现有结点数
} PTree;
</pre>
<p>数据结构不仅要存储元素本身，还要存储元素相互之间的关系，对于线性数据结构，如果用顺序存储，则顺序存储本身就是线性关系，可以体现元素之间的关系，所以对于元素之间的关系不需要额外的数据来存储。这是一种最简单的数据逻辑关系与存储关系。</p>

<p>对于线性关系如果想通过链式存储，则需要一个结构体或类，来存储元素本身及元素下一个链接的地址或引用。对于线性关系以外的树型层次关系与图形关系，二叉树是相对简单的一种数据结构，可以用顺序存储来实现。此外的其它树型层次关系与图的网络关系则一定需要对元素及元素的关系进行数据化，也就是除了存储元素本身以外，还需要存储元素之间的关系，如树型层次中的双亲、孩子、兄弟关系及图形中的边的关系。这样的数据结构其实是一个多维的线性关系，需要用复杂的数据结构来实现。如树型的双亲存储、孩子存储及图形的二维邻接矩阵、邻接表等。或者用二维矩阵实现或者用结构体或类来实现对元素及元素关系（双亲、孩子、边）的存储。</p>
<p>Typedef struct node{</p>

<p>DataType data;  //结点数据（存储数据元素本身）</p>

<p>int parent; //结点双亲（存储元素之间的关系）</p>

<p>} PTNode;</p>
<p>数据结构={数据元素构成，数据元素的逻辑关系，数据元素存储方式，数据元素运算}</p>

<p>有多个地点需要连通，两点之间的连通（边）有不同的权值，构成一张加权连通图，需要实现连通所有顶点，且其所有边的权值之和亦为最小。这就是图论中的一种算法，可在里搜索最小生成树。该算法于1930年由捷克数学家沃伊捷赫·亚尔尼克（英语：Vojtěch Jarník）发现；并在1957年由美国计算机科学家罗伯特·普里姆（英语：Robert C. Prim）独立发现；1959年，艾兹格·迪科斯彻再次发现了该算法。因此，在某些场合，普里姆算法又被称为DJP算法、亚尔尼克算法或普里姆－亚尔尼克算法。</p>

<p>有多个点需要连通，两点之间的连通（边）有不同的权值，构成一张加权连通图，需要实现连通所有顶点，且其所有边的权值之和亦为最小。这就是图论中的一种算法，可在里搜索最小生成树（所有点成树有最小总权和）。</p>

<p>一个无向图，如果某个子图中任意两个定点都互相连通并且是一棵树，那么这棵树就叫做生成树。如果边上有权值，那么使得边权和最小的生成树叫做最小生成树。</p>

<p>Prim算法</p>

<p>找一个起始点加入树，对所有点寻找到到树的距离，从中选择最小的加入树，再次更新距离，从中寻找最小的，直到所有点都加入树。</p>

<p>Kruskal算法</p>

<p>对权值进行排序，然后从小到大进行判断，如果加入这条边，不成环则是所求树的边。(结合并查集)</p>

<p>《趣学算法》源码</p>

<p>https://blog.csdn.net/rainchxy/article/details/75044202</p>

<p>chapter2   链接：https://pan.baidu.com/s/1ggkOOD1 密码：suna</p>

<p>chapter3  链接：https://pan.baidu.com/s/1eSYFBpw 密码：huz6</p>

<p>chapter4  链接：https://pan.baidu.com/s/1rabZqnq 密码：xquj</p>

<p>chapter5  链接：https://pan.baidu.com/s/1eTQOtDg 密码：sqd4</p>

<p>chapter6  链接：https://pan.baidu.com/s/1cQGq2i 密码：w6xf</p>

<p>chapter7  链接：https://pan.baidu.com/s/1rahyXf2 密码：v7b4</p>

<p>appendix 链接：https://pan.baidu.com/s/1bq6BGej 密码：132v</p>

<p>算法7-1更新（2017.11.23）：</p>

<p>链接：https://pan.baidu.com/s/1eTYVPSY 密码：i11k</p>

<p>趣学算法pdf高清无水印版下载</p>

<p>最近在网上找趣学算法pdf，最后还是买了完整版，今天将本书分享出来，分享给那些和我一样在网上苦苦寻找的小可爱们，有条件的话请支持正版！</p>

<p>链接：https://pan.baidu.com/s/1Mg7F_HHuDtD9bOBkPh7SRQ 密码：8nlc</p>

<p>分析一个具有代表性、简单性的、特殊性的问题，考虑合适的算法，按照机械思维模拟计算机的求解过程，然后用编程语言描述之。</p>

<p>如果一个函数在其函数体内直接或间接地调用了自己，该函数就称为递归函数，它通常将一个大型复杂的问题一层层地转化为一个与原问题相似的但规模较小的问题求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码。</p>

<p>一般来讲，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进，当边界条件满足时，递归返回。在使用递归策略时，必须有一个明确的递归结束条件，称为递归出口。</p>

<p>设计递归算法，主要有两步：</p>

<p>1 确定递归公式；</p>

<p>2 确定边界（终了）条件。</p>

<p>递归函数的一般格式：</p>

<p></p>
<pre>
if(边界条件1成立)
{
	赋予边界值1
}
else if(边界条件2成立)
{
	赋予边界值2
}
else
{
	调用递归公式
}
</pre><p>散列函数准确地指出了元素的存储位置，你根本不用查找！之所以能够这样，具体原因如下。</p>

<p>散列函数总是将同样的输入映射到相同的索引。每次你输入avocado，得到的都是同一个数字。因此，你可首先使用它来确定将鳄梨的价格存储在什么地方，并在以后使用它来确定鳄梨的价格存储在什么地方。</p>

<p>散列函数将不同的输入映射到不同的索引。avocado映射到索引4，milk映射到索引0。每种商品都映射到数组的不同位置，让你能够将其价格存储到这里。</p>

<p>散列函数知道数组有多大，只返回有效的索引。如果数组包含5个元素，散列函数就不会返回无效索引100。</p>

<p>数组和链表都被直接映射到内存，但散列表更复杂，它使用散列函数来确定元素的存储位置。在你将学习的复杂数据结构中，散列表可能是最有用的，也被称为散列映射、映射、字典和关联数组。散列表的速度很快！还记得第2章关于数组和链表的讨论吗？你可以立即获取数组中的元素，而散列表也使用数组来存储数据，因此其获取元素的速度与数组一样快。</p>

<p>你可能根本不需要自己去实现散列表，任一优秀的语言都提供了散列表实现。Python提供的散列表实现为字典，你可使用函数dict来创建散列表。</p>

<p>散列表由键和值组成。散列表让你能够轻松地模拟映射关系。散列表被用于大海捞针式的查找。</p>

<p>缓存是一种常用的加速方式，所有大型网站都使用缓存，而缓存的数据则存储在散列表中！Facebook不仅缓存主页，还缓存About页面、Contact页面、Terms and Conditions页面等众多其他的页面。因此，它需要将页面URL映射到页面数据。</p>

<p>当你访问Facebook的页面时，它首先检查散列表中是否存储了该页面。</p>
<p></p>
<pre>
cache = {}
def get_page(url):
if cache.get(url):
    return cache[url]
else:
    data = get_data_from_server(url)
cache[url] = data
return data
</pre>

<p>仅当URL不在缓存中时，你才让服务器做些处理，并将处理生成的数据存储到缓存中，再返回它。这样，当下次有人请求该URL时，你就可以直接发送缓存中的数据，而不用再让服务器进行处理了。</p>

<p>良好的散列函数让数组中的值呈均匀分布。</p>

<p>糟糕的散列函数让值扎堆，导致大量的冲突。</p>

<p>什么样的散列函数是良好的呢？你根本不用操心——天塌下来有高个子顶着。如果你好奇，可研究一下SHA函数（本书最后一章做了简要的介绍）。你可将它用作散列函数。</p>

<p>你几乎根本不用自己去实现散列表，因为你使用的编程语言提供了散列表实现。你可使用Python提供的散列表，并假定能够获得平均情况下的性能：常量时间。</p>

<p>散列表是一种功能强大的数据结构，其操作速度快，还能让你以不同的方式建立数据模型。</p>

<p>你可能很快会发现自己经常在使用它。</p>

<p>你可以结合散列函数和数组来创建散列表。</p>

<p>冲突很糟糕，你应使用可以最大限度减少冲突的散列函数。</p>

<p>散列表的查找、插入和删除速度都非常快。</p>

<p>散列表适合用于模拟映射关系。</p>

<p>一旦填装因子超过0.7，就该调整散列表的长度。</p>

<p>散列表可用于缓存数据（例如，在Web服务器上）。</p>

<p>散列表非常适合用于防止重复。</p>

<p>队列只支持两种操作：入队和出队。</p>

<p>树是一种特殊的图，其中没有往后指的边。</p>

<p>贪婪算法寻找局部最优解，企图以这种方式获得全局最优解。</p>

<p>需要在给定约束条件下优化某种指标时，动态规划很有用。</p>

<p>问题可分解为离散子问题时，可使用动态规划来解决。</p>

<p>每种动态规划解决方案都涉及网格。</p>

<p>单元格中的值通常就是你要优化的值。</p>

<p>每个单元格都是一个子问题，因此你需要考虑如何将问题分解为子问题。</p>

<p>没有放之四海皆准的计算动态规划解决方案的公式。</p>

<p>使用K最近邻算法创建分类系统。</p>

<p>特征抽取。</p>

<p>回归，即预测数值，如明天的股价或用户对某部电影的喜欢程度。</p>

<p>K最近邻算法的应用案例和局限性。</p>

<p>归并函数可能令人迷惑，其理念是将很多项归并为一项。映射是将一个数组转换为另一个数组。</p>

<p>而归并是将一个数组转换为一个元素。</p>

<p>散列算法，假设你有一个键，需要将其相关联的值放到数组中。你使用散列函数来确定应将这个值放在数组的什么地方。你将值放在这个地方。这样查找时间是固定的。当你想要知道指定键对应的值时，可再次执行散列函数，它将告诉你这个值存储在什么地方，需要的时间为O(1)。你希望散列函数的结果是均匀分布的。散列函数接受一个字符串，并返回一个索引号。</p>

<p>二分查找的基线条件是数组只包含一个元素。如果要查找的值与这个元素相同，就找到了！否则，就说明它不在数组中。在二分查找的递归条件中，你把数组分成两半，将其中一半丢弃，并对另一半执行二分查找。</p>

<p>一般将递归程序改成非递归首先想到的就是使用栈，因为递归本身就是一个压栈的过程。</p>

<p>希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小，插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比o(n^2)好一些。</p>
<p></p>
<pre>
template
T triangleArea (T base, T height)
{
	return base * height * .5;
}
triangleArea(.5, .5); //模板的参数应该是一个类型而不是一个值
</pre>
<p>代码出现T的任何地方，它都会被double代替。<double>就像是一个这样的数据类型替代声明。</p>

<p>在有些情况下，编译器也可以根据函数的参数来推断模板参数的值：</p>

<p>triangleArea(.5, .5);</p>

<p>■Array：数组，有次序性（需依序处理），可动态增减大小，索引值为整数。</p>

<p>■List：双向串行，有次序性（需依序处理），无索引。串行有头尾，可从头尾或从串行的任何位置安插元素，速度极快。</p>

<p>■Map：又称为Dictionary，其内对象成对存在，一为键值对象（key object），一为实值对象（value object）。</p>

<p>使用分治法求解的一些经典问题有：二分搜索、合并排序、快速排序、汉诺塔问题。</p>

<p>用动态规划法解题时，将和子问题相关的各个变量的一组取值，称之为一个“状态”。一个“状态”对应于一个或多个子问题，所谓某个“状态”下的“值”，就是这个“状态”所对应的子问题的解。</p>

<p>贪心算法只能通过局部最优解来达到最局最优解。</p>

<p>基础数据结构有3大类，分别是线性、树状和图状。线性数据结构主要有线性表、单向链表和双向链表，线性数据结构的判断基础是，除了首元素和尾元素，其他元素都只有一个前驱和一个后继。树状结构是无环结构，即除根节点外，每个节点都有一个前驱和若干后继，但不能形成环路。图状则涵盖了前两者类型，也允许有环路。</p>

<p>要进行程序设计，除了需要了解程序设计语言，如C/C++等，还需要对数据库，操作系统和计算机网络等有所了解。 </p>

<p>数据库是一些应用程序中业务数据存储的工具。在很多项目中，数据库是必不可少的。操作系统是应用程序运行的环境，不同的操作系统的应用程序的开发有所不同。通过操作系统提供的系统函数，可以实现应用程序与操作系统的交互。而计算机网络，主要是在开发涉及到网络通讯的应用程序时，需要使用到相关的知识。</p>

<p>数据库是大多数应用程序数据存储的核心。通过将数据存储在数据库中，可以将数据存储相关的操作用数据库系统进行。从而减少自主开发新的数据存储系统的时间，加快应用程序的开发速度。数据库系统是由一整套数据库理论所支持的，要熟练地使用数据库，设计一个良好的数据库结构，是需要对数据库理论有一定的了解。</p>

<p>数据结构，一组数据及其相互关系，并且定义了诸如增、删、改、查等的一组操作（函数或类方法）</p>

<p>二叉树结合了有序数组和链表的优点。在二叉树中查找数据与在数组中查找数据一样块，在二叉树中添加、删除数据的速度也和在链表中一样高效。</p>

<p>集合、关系、操作的组合就是数组结构。</p>

<p>栈是先进后出，队列是后进先出，优先级队列并不看数据抵达的先后顺序，而是以数据内的键为基准判断优先级，优先级高的数据先被取出。</p>

<p>优先队列一般用二叉搜索树或二叉堆来实现。</p>

<p>迭代算法是用计算机解决问题的一种基本方法。它利用计算机运算速度快、适合做重复性操作的特点，让计算机对一组指令（或一定步骤）进行重复执行，在每次执行这组指令（或这些步骤）时，都从变量的原值推出它的一个新值。</p>

<p>在可以用迭代算法解决的问题中，至少存在一个直接或间接地不断由旧值递推出新值的变量，这个变量就是迭代变量。</p>

<p>所谓迭代关系式，指如何从变量的前一个值推出其下一个值的公式（或关系）。迭代关系式的建立是解决迭代问题的关键，通常可以使用递推或倒推的方法来完成。</p>

<p>在什么时候结束迭代过程?这是编写迭代程序必须考虑的问题。不能让迭代过程无休止地重复执行下去。迭代过程的控制通常可分为两种情况：一种是所需的迭代次数是个确定的值，可以计算出来；另一种是所需的迭代次数无法确定。对于前一种情况，可以构建一个固定次数的循环来实现对迭代过程的控制；对于后一种情况，需要进一步分析出用来结束迭代过程的条件。</p>

<p>递归其实就是利用系统堆栈，实现函数自身调用，或者是相互调用的过程。在通往边界的过程中，都会把单步地址保存下来，再接照先进后出进行运算。递归的数据传送也类似。</p>

<p>递归的运算方法，决定了它的效率较低，因为数据要不断地进出栈。在应用递归时，只要输入的n值稍大，程序求解就比较困难。因而从计算效率来说，递推往往要髙于递归。</p>

<p>递推免除了数据进出栈的过程，也就是说,不需要函数不断地的向边界值靠拢，而直接从边界出发，逐步推出函数值， 直观明了。</p>

<p>在有些情况下，递归可以转化为效率较髙的递推。但是递归作为重要的基础等法，它的作用不可替代。</p>

<p>迭代：利用变量的原值推算出变量的一个新值，如果递归是自己调用自己的话，迭代就是A不停的调用B。</p>

<p>递推：它是按照一定的规律来计算序列中的每个项，通常是通过计算机前面的一些项来得出序列中的指定象的值。其思想是把一个复杂的庞大的计算过程转化为简单过程的多次重复。</p>

<p>递归与递推区别：递归的步骤中包含递推，如一个规模为n的问题，递归首先通过回溯将问题回溯到n-1，n-2……，然后再通过递推从1的结果一直递推到n。</p>

<p>递归与迭代的区别：递归中一定有迭代，但是迭代中不一定有递归，大部分可以相互转换。能用迭代的不用递归，递归调用函数，浪费空间，并且递归太深容易造成堆栈的溢出。</p>

<p>可以这么理解，递推和迭代都是正向的将一个复杂问题分解为小问题，一步一步得出结果；而递归是逆向的，多了一步回溯的过程。</p>

<p>每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值。</p>
<p></p>
<pre>
int fib(int n) {
	if (n == 0 || n == 1) return 1;
	return fib(n - 1) + fib(n - 2);
}
</pre>

<p>Again, we emphasize that while this function is neat, concise, and easy to understand, it is not efficient.</p>

<p>For example, consider the calculation of F(5).</p>

<p>F(5) </p>

<p>= F(4) + F(3) </p>

<p>= F(3) + F(2) + F(3) </p>

<p>= F(2) + F(1) + F(2) + F(3)</p>

<p>= F(1) + F(0) + F(1) + F(2) + F(3) </p>

<p>= 1 + 1 + 1 + F(1) + F(0) + F(3)</p>

<p>= 1 + 1 + 1 + 1 + 1 + F(2) + F(1) </p>

<p>= 1 + 1 + 1 + 1 + 1 + F(1) + F(0) + F(1)</p>

<p>= 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1</p>

<p>= 8</p>

<p></P>

<p></p>
<pre>
void decToBin(int n) 
{    
	if (n > 0) 
	{        
		decToBin(n / 2);        
		printf("%d ", n % 2);    
	}
}

The call decToBin(13) will print 1101.
decToBin(13)
decToBin(6)
print(13 % 2)
decToBin(3)
print(6 % 2)
print(13 % 2)
decToBin(1)
print(3 % 2)
print(6 % 2)
print(13 % 2)
decToBin(0) = do nothing
print(1 % 2) = 1
print(3 % 2) = 1
print(6 % 2) = 0
print(13 % 2) = 1
</pre>


<p>所谓数据结构，就是指数据之间的相互关系以及在这些数据上定义的数据运算方法的集合。数据结构一般分两种，一种称为逻辑结构，一种称为物理结构。其中，常见的逻辑结构有四类，分别是集合、线性表、树型结构、图。</p>

<p>在软件开发中，大量的数据，需要用比较好的方式表示在内存中，并且，这种表示方法，非常方便我们使用这些数据。这个需求，促使了数据结构和算法技术的发展。</p>

<p>A stack is a data structure that retrieves data in the reverse order the data was stored.</p>

<p>A queue is a data structure that retrieves data in the same order the data was stored.</p>

<p>recursion simply called itself with a different argument.</p>

<p>递归的执行顺序：</p>

<p>调用：递归函数前的代码；</p>

<p>回推：递归函数后的代码；</p>

<p>顺序结构、选择结构、循环结构的共同特点：</p>

<p>(1)只有一个入口。 </p>

<p>(2)只有一个出口。</p>

<p>(3)结构内的每一部分都有机会被执行到。</p>

<p>(4)结构内不存在“死循环”(无终止的循环)</p>

<p>一个结构化的算法是由一些基本结构顺序组成的。在基本结构之间不存在向前或向后的跳转，流程的转移只存在于一个基本结构范围之内(如循环中流程的跳转)；一 个非结构化的算法可以用一个等价的结构化算法代替，其功能不变 。如果一个算法不能分解为若干个基本结构，则它必然不是一个结构化的算法</p>

<p>根据二叉树的性质：二叉树第i（i≥1）层上至多有2^i-1+个结点。得到第5层的结点数最多是16。</p>
<p>所谓满二叉树是指这样的一种二叉树：除最后一层外，每一层上的所有结点都有两个叶子结点。这就是说，在满二叉树中，层上的结点数都达到最大值，即在满二叉树的第k层上有2k-1个结点，且深度为m的满二叉树有2m-1个结点。</p>
<p>一些较流行的程序语言允许过程的递归调用。递归调用就是过程调用本身。递归实现的是：当过程每一次执行后，都能返回到最近一次调用它的过程中。这样各调用点之间形成一种后进先出关系，而栈结构正适合来存储这些调用点。</p>
<p>外模式是用户的数据视图，也就是用户所见到的数据模式；全局数据视图的描述称为概念模式，即数据库中全部数据的整体逻辑结构的描述；物理存储数据视图的描述称为内模式，即数据库在物理存储方面的描述；存储模式即为内模式。</p>
<p>数据的逻辑结构是指反映数据元素之间逻辑关系的数据结构；数据的存储结构是指数据的逻辑结构在计算机存储空间中的存放形式。在数据的存储结构中，不仅要存放各数据元素的信息，还需要存放各数据元素之间的前后件关系的信息。</p>
<p>数据库中的数据具有"集成"与"共享"的特点，亦即是数据库集中了各种应用的数据，进行统一构造与存储，而使它们可以被不同应用程序所使用</p>
<p>在关系模型中，把数据看成一个二维表，每一个二维表称为一个关系。表中的每一列称为一个属性，相当于记录中的一个数据项，对属性的命名称为属性名；表中的一行称为一个元组，相当于记录值。</p>
<p>在内存中，字符数据以ASCII码存储，它的存储形式就与整数的存储形式相类似。C++语言使字符型数据和整型数据之间可以通用。也可以对字符数据进行算术运算，此时相当于对它们的ASCII码进行算术运算。</p>

<p>存储只有线性关系，不管是顺序存储还是链式存储</p>
<p></p>
<pre>
void dec2(unsigned long n)
{
	int r;
	r=n%2; //最后一位
	if(n>=2)
		dec2(n/2);//递归后进先出的特点很适合倒序计算；
	putchar(r==0?'0':'1');
}
</pre><p>无论那种搜索，都是通过对一个线性表进行处理，只不过是先处理头部还是尾部的问题罢了。处理头部优先的时候，也就是先加入的先探索，就是广度优先了，因为，头部的都是兄弟节点；而尾部的则是深度优先，因为放入尾部的都是刚刚生产出来的节点，后加入的先探索——也就是所谓一条路走到死。 同理可以联想到启发式搜索。启发式搜索就是先以你自定义的优先级处理，然后再以广度为优先级处理。 所以，归根结底，所谓的搜索，就是一种定义了优先级的枚举。</p>
<p>当调用一个函数时，系统内部发生了一系列的动作。</p>
<p>(1)开辟函数的栈空间</p>
<p>(2)将当前运行状态压栈</p>
<p>(3)将返回地址(调用函数的地方)压栈</p>
<p>(4)在栈内分配参数空间，传递参数信息</p>
<p>(5)执行被调用函数，如果有局部变量，则在栈内分配空间</p>
<p></p>
<p>当函数运行结束时，系统内部又一系列的动作，这些恰巧与调用函数时的动作顺序相反。</p>
<p>(1)释放栈内局部变量空间</p>
<p>(2)释放栈内参数空间</p>
<p>(3)退栈，得到返回地址，程序跳转到调用函数处等待继续执行</p>
<p>(4)退栈，得到程序运行状态，恢复调用函数前的状态。</p>
<p>(5)释放该函数的栈空间</p>
<p>顺序存储的线性表的特点：</p>
<p>线性表的逻辑顺序与物理顺序一致;</p>
<p>数据元素之间的关系是以元素在计算机内“物理位置相邻”来体现。</p>
<p>为了正确表示结点间的逻辑关系，在存储每个结点值的同时，还必须存储指示其直接后继结点的地址(或位置)，称为指针(pointer)或链(link)，这两部分组成了链表中的结点结构</p>
<p>分治法所能解决的问题一般具有以下几个特征：</p>
<p>1 该问题的规模缩小到一定的程度就可以容易地解决；</p>
<p>2 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质</p>
<p>3 利用该问题分解出的子问题的解可以合并为该问题的解；</p>
<p>4 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。 </p>
<p>因为问题的计算复杂性一般是随着问题规模的增加而增加，因此大部分问题满足这个特征。</p>
<p>这条特征是应用分治法的前提，它也是大多数问题可以满足的，此特征反映了递归思想的应用</p>
<p>能否利用分治法完全取决于问题是否具有这条特征，如果具备了前两条特征，而不具备第三条特征，则可以考虑贪心算法或动态规划。</p>
<p>这条特征涉及到分治法的效率，如果各子问题是不独立的，则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然也可用分治法，但一般用动态规划较好。</p>
<p>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题</p>
<p></p>
<p></p>
<p>但是经分解得到的子问题往往不是互相独立的。不同子问题的数目常常只有多项式量级。在用分治法求解时，有些子问题被重复计算了许多次。</p>
<p></p>
<p>如果能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，就可以避免大量重复计算，从而得到多项式时间算法。</p>
<p>递归算法求解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。这种性质称为子问题的重叠性质。</p>
<p></p>
<p>动态规划算法，对每一个子问题只解一次，而后将其解保存在一个表格中，当再次需要解此子问题时，只是简单地用常数时间查看一下结果。 </p>
<p></p>
<p>通常不同的子问题个数随问题的大小呈多项式增长。因此用动态规划算法只需要多项式时间，从而获得较高的解题效率。</p>
<p>顾名思义，贪心算法总是作出在当前看来最好的选择。也就是说贪心算法并不从整体最优考虑，它所作出的选择只是在某种意义上的局部最优选择。当然，希望贪心算法得到的最终结果也是整体最优的。虽然贪心算法不能对所有问题都得到整体最优解，但对许多问题它能产生整体最优解。如单源最短路经问题，最小生成树问题等。在一些情况下，即使贪心算法不能得到整体最优解，其最终结果却是最优解的很好近似。</p>
<p>贪心算法和动态规划算法都要求问题具有最优子结构性质，这是2类算法的一个共同点。但是，对于具有最优子结构的问题应该选用贪心算法还是动态规划算法求解?是否能用动态规划算法求解的问题也能用贪心算法求解</p>
<p>有许多问题，当需要找出它的解集或者要求回答什么解是满足某些约束条件的最佳解时，往往要使用回溯法。</p>
<p>回溯法的基本做法是搜索，或是一种组织得井井有条的，能避免不必要搜索的穷举式搜索法。这种方法适用于解一些组合数相当大的问题。</p>
<p>回溯法在问题的解空间树中，按深度优先策略，从根结点出发搜索解空间树。算法搜索至解空间树的任意一点时，先判断该结点是否包含问题的解。如果肯定不包含，则跳过对该结点为根的子树的搜索，逐层向其祖先结点回溯；否则，进入该子树，继续按深度优先策略搜索。</p>
<p>回溯法的基本思想</p>
<p>(1)针对所给问题，定义问题的解空间；</p>
<p>(2)确定易于搜索的解空间结构；</p>
<p>(3)以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</p>
<p></p>
<p>常用剪枝函数：</p>
<p>用约束函数在扩展结点处剪去不满足约束的子树；</p>
<p>用限界函数剪去得不到最优解的子树。</p>
<p>用回溯法解题的一个显著特征是在搜索过程中动态产生问题的解空间。在任何时刻，算法只保存从根结点到当前扩展结点的路径。如果解空间树中从根结点到叶结点的最长路径的长度为h(n)，则回溯法所需的计算空间通常为O(h(n))。而显式地存储整个解空间则需要O(2h(n))或O(h(n)!)内存空间。</p>
<p>分支限界法与回溯法的不同</p>
<p>（1）求解目标：回溯法的求解目标是找出解空间树中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出在某种意义下的最优解。 </p>
<p>（2）搜索方式的不同：回溯法以深度优先的方式搜索解空间树，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树。</p>
<p>分支限界法基本思想</p>
<p> 分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。</p>
<p> 在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中。</p>
<p> 此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所需的解或活结点表为空时为止。</p>
<p>常见的两种分支限界法</p>
<p>（1）队列式(FIFO)分支限界法</p>
<p>    按照队列先进先出（FIFO）原则选取下一个节点为扩展节点。 </p>
<p>（2）优先队列式分支限界法</p>
<p>    按照优先队列中规定的优先级选取优先级最高的节点成为当前扩展节点。</p>
<p>有一个待办事项清单。你可将待办事项添加到该清单的任何地方，还可删除任何一个待办事项。一叠便条要简单得多：插入的待办事项放在清单的最前面；读取待办事项时，你只读取最上面的那个，并将其删除。因此这个待办事项清单只有两种操作：压入（插入）和弹出（删除并读取）。</p>
<p>散列函数总是将同样的输入映射到相同的索引。</p>
<p>在广度优先搜索的执行过程中，搜索范围从起点开始逐渐向外延伸，即先检查一度关系，再检查二度关系。</p>
<p>你需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必须是队列。对于检查过的人，务必不要再去检查，否则可能导致无限循环。</p>
<p>广度优先搜索用于在非加权图中查找最短路径。狄克斯特拉算法用于在加权图中查找最短路径。仅当权重为正时狄克斯特拉算法才管用。如果图中包含负权边，请使用贝尔曼?福德算法。</p>
<p>Binary search is a good example of an O(log n) algorithm.</p>
<p>A binary tree of height 1 can have up to 2 leaf nodes, while a tree of height two  can have up to four leaves. What is the height h of a rooted binary tree with n leaf  nodes? Note that the number of leaves doubles every time we increase the height  by one. To account for n leaves, n = 2h which implies that h = log2 n.</p>
<p>Data structures can be neatly classified as either contiguous or linked, depending upon whether they are based on arrays or pointers:</p>
<p>Contiguously-allocated structures are composed of single slabs of memory, and include arrays, matrices, heaps, and hash tables.</p>
<p>Linked data structures are composed of distinct chunks of memory bound together by pointers, and include lists, trees, and graph adjacency lists.</p>
<p>We use the term container to denote a data structure that permits storage and  retrieval of data items independent of content. By contrast, dictionaries are abstract  data types that retrieve based on key values or content.</p>

<p>Containers are distinguished by the particular retrieval order they support. In  the two most important types of containers, this retrieval order depends on the  insertion order.</p>
<p>Hash tables are a very practical way to maintain a dictionary. They exploit the fact  that looking an item up in an array takes constant time once you have its index. A  hash function is a mathematical function that maps keys to integers. We will use  the value of our hash function as an index into an array, and store our item at that  position.</p>
<p>Many algorithms process items in a specific order. For example, suppose you must  schedule jobs according to their importance relative to other jobs. Scheduling the jobs requires sorting them by importance, and then evaluating them in this sorted  order.  </p>
<p>Priority queues are data structures that provide more flexibility than simple  sorting, because they allow new elements to enter a system at arbitrary intervals.  It is much more cost-effective to insert a new job into a priority queue than to  re-sort everything on each such arrival.</p>
<p>Many naturally occurring processes are accurately modeled by priority queues.  Single people maintain a priority queue of potential dating candidates—mentally  if not explicitly. One’s impression on meeting a new person maps directly to an  attractiveness or desirability score. Desirability serves as the key field for inserting  this new entry into the “little black book” priority queue data structure. Dating is  the process of extracting the most desirable person from the data structure (Find-  Maximum), spending an evening to evaluate them better, and then reinserting  them into the priority queue with a possibly revised score.</p>
<p>Selecting the right graph data structure can have an enormous impact on performance.  Your two basic choices are adjacency matrices and adjacency lists.</p>
<p>Our search must take us through  every edge and vertex in the graph.</p>
<p>The key idea behind graph traversal is to mark each vertex when we first visit  it and keep track of what we have not yet completely explored. Although bread  crumbs or unraveled threads have been used to mark visited places in fairy-tale  mazes, we will rely on Boolean flags or enumerated types.</p>
<p>Each vertex will exist in one of three states:</p>
<p></p>
<p>undiscovered – the vertex is in its initial, virgin state.</p>
<p></p>
<p>discovered – the vertex has been found, but we have not yet checked out all its incident edges.</p>
<p></p>
<p>processed – the vertex after we have visited all its incident edges.</p>
<p>Obviously, a vertex cannot be processed until after we discover it, so the state  of each vertex progresses over the course of the traversal from undiscovered to  discovered to processed.</p>
<p>We must also maintain a structure containing the vertices that we have discovered  but not yet completely processed. Initially, only the single start vertex is  considered to be discovered. To completely explore a vertex v, we must evaluate  each edge leaving v. If an edge goes to an undiscovered vertex x, we mark x discovered  and add it to the list of work to do. We ignore an edge that goes to a  processed vertex, because further contemplation will tell us nothing new about the  graph. We can also ignore any edge going to a discovered but not processed vertex,  because the destination already resides on the list of vertices to process.</p>
<p>Once a vertex is discovered, it is placed on a queue. Since we process these  vertices in first-in, first-out order, the oldest vertices are expanded first, which are  exactly those closest to the root.</p>
<p>The difference between BFS and DFS results is in the order in which they  explore vertices. This order depends completely upon the container data structure  used to store the discovered but not processed vertices.</p>
<p>Queue – By storing the vertices in a first-in, first-out (FIFO) queue, we  explore the oldest unexplored vertices first. Thus our explorations radiate  out slowly from the starting vertex, defining a breadth-first search.</p>
<p>Stack – By storing the vertices in a last-in, first-out (LIFO) stack, we explore  the vertices by lurching along a path, visiting a new neighbor if one is available,  and backing up only when we are surrounded by previously discovered  vertices. Thus, our explorations quickly wander away from our starting point,  defining a depth-first search.</p>
<p>Depth-first search has a neat recursive implementation, which eliminates theneed to explicitly use a stack.</p>
<p>We need to be able to take separate actions on each entry and exit.</p>
<p>The other important property of a depth-first search is that it partitions the  edges of an undirected graph into exactly two classes: tree edges and back edges. The  tree edges discover new vertices, and are those encoded in the parent relation. Back  edges are those whose other endpoint is an ancestor of the vertex being expanded,  so they point back into the tree.</p>
<p>深度优先搜索：一条道走到底，不撞南山不回头。</p>
<p>广度优先搜索：一层一层探索，逐层扩展；</p>
<p>散列函数是这样的函数，即无论你给它什么数据，它都还你一个数字。</p>
<p>散列函数总是将同样的输入映射到相同的索引。</p>
<p>散列函数将不同的输入映射到不同的索引。</p>
<p>散列函数知道数组有多大，只返回有效的索引。</p>
<p>数组和链表都被直接映射到内存，但散列表更复杂，它使用散列函数来确定元素的存储位置。</p>
<p>散列表也使用数组来存储数据，因此其获取元素的速度与数组一样快。</p>
<p>广度优先搜索是一种分层的搜索过程，不像深度优先遍历那样有往回退的情况。因此，广度优先遍历不能递归实现，可以使用先进先出的队列来实现。</p>
<p>索引：是通过增加索引表；</p>
<p>散列：通过用关键字做为地址，如数组的下标是首地址的偏移量，而散列表也可以模仿数据，做关键字通过散列函数映射到各下标。</p>
<p>Creating Loops easily---From the inside out!</p><p>栈可以用一个数组来模拟，用一个整数变量top来控制可以使用的下标上限。</p><p>链式存储一般是在堆中实现的存储的。</p><p>队列来是如此，可以用一个数组来模拟一个顺序队列，用两个指示变量来做下标控制；</p><p>散列表又名哈希表或字典，在动态编程中常用于存储键/值（key/value）数据。散列表针对键执行一个散列计算，产生一个整数，使用这一整数找到一个桶（bucket），然后进行取值或者设值。散列表速度很快，也很实用。</p><p>数组，以数组名也内存块首地址为基地址，用下标来偏移计算成员数据的地址。</p><p>是否可以以字符串为下标为进行偏移呢？就是要计算字符串与下标数字的对应关系，元素数量为映射空间。</p><p>数据结构描述数据元素的集合及元素间的关系和运算。</p><p>查找时理想的情况是依据记录的关键码直接得到其对应的存储位置，即要求记录的关键码与其存储位置之间存在一一对应关系，从而快速地找到记录。根据设定的哈希函数（Hash(key)）和处理冲突的方法，将一组关键码映射到一个有限的连续的地址集（区间）上，并以关键码在地址集中的“像”作为记录在表中的存储位置，这种表称为哈希表，这一映射过程称为哈希造表或散列。所得到的存储位置称为哈希地址或散列地址。</p><p>算法的大类、中类、小类</p><p>大类如排序、查找等算法；</p><p>中类是指在大类上应用的算法思想，如穷举（蛮力）法、贪心法、分治法、动态规划、回溯法；</p><p>小类是指在数据结构上应用的算法，包括增、查、删、改、遍历、图的最路径、最小生成树、树的遍历方法，线性表的二分查找，以及数据类型的运算符，类类型的操作符重载。</p><p>算法通常在函数中使用控制结构来实现。</p><p>如果相同的声明序列在不同的地方要多次出现时，我们就不得不拷贝这些序列。如果其中发生了一个错误，我们就需要对每一个拷贝进行修改.</p><p>这就导致了我们将这些序列抽取出来，单独命名，并通过调用和返回值的方法来实现多处复用的方法。</p><p>The value contained in memory where the deleted object resided is  undefined, meaning the compiler can produce code that leaves anything  there. In practice, major compilers will try to be as efficient as possible, so  typically the object’s memory will remain untouched until the program  reuses it for some other purposes. You would have to implement a custom  destructor to, for example, zero out some sensitive contents.</p>